/* eslint-disable max-len */
/**
 * This file is auto-generated by Orval. Do not edit.
 */
import { z as zod } from 'zod'

/**
 * The organization account status includes the organization Id, QCC balance, and credit card information.
 * @summary Read the organization account status.
 */
export const readAccountResponse = zod
  .object({
    organizationId: zod.string().optional().nullable().describe('The organization Id.'),
    creditBalance: zod.coerce.number().optional().nullable().describe('The current account balance.'),
    card: zod
      .object({
        brand: zod.string().optional().nullable().describe('Credit card brand.'),
        expiration: zod.string().optional().nullable().describe('The credit card expiration (mm/yy).'),
        last4: zod.string().optional().nullable().describe('The last 4 digits of the card.'),
      })
      .optional()
      .nullable()
      .describe('Credit card information.'),
  })
  .describe('Account information for an organization.')

/**
 * @summary Create a new project in your default organization.
 */
export const createProjectBody = zod
  .object({
    name: zod.string().describe('Project name.'),
    language: zod.enum(['C#', 'Py']).describe('Programming language to use.'),
    organizationId: zod
      .string()
      .optional()
      .nullable()
      .describe("The organization to create project under. If you don't provide a value, it defaults to your preferred organization."),
  })
  .describe('Request to create a project with the specified name and language via QuantConnect.com API.')

export const createProjectResponse = zod
  .object({
    projects: zod
      .array(
        zod
          .object({
            projectId: zod.coerce.number().describe('Project id.'),
            organizationId: zod.string().describe('Orgainization id.'),
            name: zod.string().describe('Name of the project.'),
            modified: zod.coerce.date().describe('Modified date for the project.'),
            created: zod.coerce.date().describe('Date the project was created.'),
            ownerId: zod.coerce.number().describe('Owner id.'),
            language: zod.enum(['C#', 'Py']).describe('Programming language of the project.'),
            collaborators: zod
              .array(
                zod.object({
                  uid: zod.coerce.number().optional().nullable().describe('User ID.'),
                  liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
                  permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
                  publicId: zod.string().optional().nullable().describe('The user public ID.'),
                  profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
                  email: zod.string().optional().nullable().describe('The registered email of the user.'),
                  name: zod.string().optional().nullable().describe('The display name of the user.'),
                  bio: zod.string().optional().nullable().describe('The biography of the user.'),
                  owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
                })
              )
              .optional()
              .nullable()
              .describe('List of collaborators.'),
            leanVersionId: zod.coerce.number().optional().nullable().describe('The version of LEAN this project is running on.'),
            leanPinnedToMaster: zod.boolean().optional().nullable().describe('Indicate if the project is pinned to the master branch of LEAN.'),
            owner: zod.boolean().optional().nullable().describe('Indicate if you are the owner of the project.'),
            description: zod.string().optional().nullable().describe('The project description.'),
            channelId: zod.string().optional().nullable().describe('Channel id.'),
            parameters: zod
              .union([
                zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
                zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
              ])
              .optional()
              .nullable(),
            libraries: zod
              .array(
                zod.object({
                  projectId: zod.coerce.number().describe('Project Id of the library project.'),
                  libraryName: zod.string().optional().nullable().describe('Name of the library project.'),
                  ownerName: zod.string().optional().nullable().describe('Name of the library project owner.'),
                  access: zod.boolean().optional().nullable().describe('Indicate if the library project can be accessed.'),
                })
              )
              .optional()
              .nullable()
              .describe('The library projects.'),
            grid: zod
              .object({
                xs: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xs (Extra small) position.'),
                sm: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the sm (Small) position.'),
                md: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the md (Medium) position.'),
                lg: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the lg (Large) position.'),
                xl: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xl (Extra large) position.'),
              })
              .optional()
              .nullable()
              .describe('The grid arrangement of charts.'),
            liveGrid: zod
              .object({
                xs: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xs (Extra small) position.'),
                sm: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the sm (Small) position.'),
                md: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the md (Medium) position.'),
                lg: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the lg (Large) position.'),
                xl: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xl (Extra large) position.'),
              })
              .optional()
              .nullable()
              .describe('The grid arrangement of charts.'),
            paperEquity: zod.coerce.number().optional().nullable().describe('The equity value of the last paper trading instance.'),
            lastLiveDeployment: zod.coerce.date().optional().nullable().describe('The last live deployment active time.'),
            liveForm: zod
              .object({
                brokerageData: zod
                  .object({
                    authentication: zod
                      .object({})
                      .optional()
                      .nullable()
                      .describe(
                        'Authentication details of the live brokerage. Details on each brokerage refers to https://www.quantconnect.com/docs/v2/lean-cli/api-reference/lean-cloud-live-deploy.'
                      ),
                    additionalProperties: zod
                      .object({
                        id: zod.string().optional().nullable().describe('The ID of the brokerage.'),
                      })
                      .optional()
                      .nullable()
                      .describe('Brokerage Id.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Brokerage data saved on live deployment.'),
                dataProvidersData: zod
                  .array(
                    zod
                      .object({
                        id: zod.string().optional().nullable().describe('The ID of the brokerage.'),
                      })
                      .describe('Brokerage Id.')
                  )
                  .optional()
                  .nullable()
                  .describe('The data providers used in the live deployment.'),
                node: zod.string().optional().nullable().describe('Node ID of the live node deployed.'),
                notifyInsights: zod.boolean().optional().nullable().describe('Indicates if notification should be issued on new insights.'),
                notifyOrderEvents: zod.boolean().optional().nullable().describe('Indicates if notification should be issued on new order events.'),
                autoRestart: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe('Indicates if the live algorithm should automatically restart after encountering runtime errors.'),
              })
              .optional()
              .nullable()
              .describe('The live wizard content used.'),
            encrypted: zod.boolean().optional().nullable().describe('Indicates if the project is encrypted.'),
            codeRunning: zod.boolean().optional().nullable().describe('Indicates if the project is running or not.'),
            leanEnvironment: zod.coerce.number().optional().nullable().describe('LEAN environment of the project running on.'),
            encryptionKey: zod
              .object({
                id: zod.string().optional().nullable().describe('Encryption key id.'),
                name: zod.string().optional().nullable().describe('Name of the encryption key.'),
              })
              .optional()
              .nullable()
              .describe('Encryption key details.'),
          })
          .describe('Response from reading a project by id.')
      )
      .optional()
      .nullable()
      .describe('List of projects for the authenticated user.'),
    versions: zod
      .array(
        zod.object({
          id: zod.coerce.number().optional().nullable().describe('Id of the LEAN version.'),
          created: zod.coerce.date().optional().nullable().describe('Date when this version was created.'),
          description: zod.string().optional().nullable().describe('Description of the LEAN version.'),
          leanHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN repository.'),
          leanCloudHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN Cloud repository.'),
          name: zod.string().optional().nullable().describe('Name of the branch where the commit is.'),
          ref: zod.string().optional().nullable().describe('Reference to the branch where the commit is.'),
          public: zod.boolean().optional().nullable().describe('Indicates if the version is available for the public.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of LEAN versions.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Project list response.')

/**
 * @summary List details of all projects, or the project matched the passed project ID if the project ID property passed.
 */
export const readProjectBodyStartDefault = 0

export const readProjectBody = zod
  .object({
    projectId: zod.number().optional().nullable().describe('Id of the project to read.'),
    start: zod
      .number()
      .optional()
      .nullable()
      .describe('Starting (inclusive, zero-based) index of the projects to fetch. If you provide this property, omit the project Id property.'),
    end: zod
      .number()
      .optional()
      .nullable()
      .describe('Last (exlusive) index of the projects to fetch. If you provide this property, omit the project Id property.'),
  })
  .describe('Request to get details about a specific project or a subset of your projects.')

export const readProjectResponse = zod
  .object({
    projects: zod
      .array(
        zod
          .object({
            projectId: zod.coerce.number().describe('Project id.'),
            organizationId: zod.string().describe('Orgainization id.'),
            name: zod.string().describe('Name of the project.'),
            modified: zod.coerce.date().describe('Modified date for the project.'),
            created: zod.coerce.date().describe('Date the project was created.'),
            ownerId: zod.coerce.number().describe('Owner id.'),
            language: zod.enum(['C#', 'Py']).describe('Programming language of the project.'),
            collaborators: zod
              .array(
                zod.object({
                  uid: zod.coerce.number().optional().nullable().describe('User ID.'),
                  liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
                  permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
                  publicId: zod.string().optional().nullable().describe('The user public ID.'),
                  profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
                  email: zod.string().optional().nullable().describe('The registered email of the user.'),
                  name: zod.string().optional().nullable().describe('The display name of the user.'),
                  bio: zod.string().optional().nullable().describe('The biography of the user.'),
                  owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
                })
              )
              .optional()
              .nullable()
              .describe('List of collaborators.'),
            leanVersionId: zod.coerce.number().optional().nullable().describe('The version of LEAN this project is running on.'),
            leanPinnedToMaster: zod.boolean().optional().nullable().describe('Indicate if the project is pinned to the master branch of LEAN.'),
            owner: zod.boolean().optional().nullable().describe('Indicate if you are the owner of the project.'),
            description: zod.string().optional().nullable().describe('The project description.'),
            channelId: zod.string().optional().nullable().describe('Channel id.'),
            parameters: zod
              .union([
                zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
                zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
              ])
              .optional()
              .nullable(),
            libraries: zod
              .array(
                zod.object({
                  projectId: zod.coerce.number().describe('Project Id of the library project.'),
                  libraryName: zod.string().optional().nullable().describe('Name of the library project.'),
                  ownerName: zod.string().optional().nullable().describe('Name of the library project owner.'),
                  access: zod.boolean().optional().nullable().describe('Indicate if the library project can be accessed.'),
                })
              )
              .optional()
              .nullable()
              .describe('The library projects.'),
            grid: zod
              .object({
                xs: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xs (Extra small) position.'),
                sm: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the sm (Small) position.'),
                md: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the md (Medium) position.'),
                lg: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the lg (Large) position.'),
                xl: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xl (Extra large) position.'),
              })
              .optional()
              .nullable()
              .describe('The grid arrangement of charts.'),
            liveGrid: zod
              .object({
                xs: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xs (Extra small) position.'),
                sm: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the sm (Small) position.'),
                md: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the md (Medium) position.'),
                lg: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the lg (Large) position.'),
                xl: zod
                  .array(
                    zod
                      .object({
                        chartName: zod.string().optional().nullable().describe('The chart name.'),
                        width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                        height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                        row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                        column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                        sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
                      })
                      .describe('The chart display properties.')
                  )
                  .optional()
                  .nullable()
                  .describe('List of chart in the xl (Extra large) position.'),
              })
              .optional()
              .nullable()
              .describe('The grid arrangement of charts.'),
            paperEquity: zod.coerce.number().optional().nullable().describe('The equity value of the last paper trading instance.'),
            lastLiveDeployment: zod.coerce.date().optional().nullable().describe('The last live deployment active time.'),
            liveForm: zod
              .object({
                brokerageData: zod
                  .object({
                    authentication: zod
                      .object({})
                      .optional()
                      .nullable()
                      .describe(
                        'Authentication details of the live brokerage. Details on each brokerage refers to https://www.quantconnect.com/docs/v2/lean-cli/api-reference/lean-cloud-live-deploy.'
                      ),
                    additionalProperties: zod
                      .object({
                        id: zod.string().optional().nullable().describe('The ID of the brokerage.'),
                      })
                      .optional()
                      .nullable()
                      .describe('Brokerage Id.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Brokerage data saved on live deployment.'),
                dataProvidersData: zod
                  .array(
                    zod
                      .object({
                        id: zod.string().optional().nullable().describe('The ID of the brokerage.'),
                      })
                      .describe('Brokerage Id.')
                  )
                  .optional()
                  .nullable()
                  .describe('The data providers used in the live deployment.'),
                node: zod.string().optional().nullable().describe('Node ID of the live node deployed.'),
                notifyInsights: zod.boolean().optional().nullable().describe('Indicates if notification should be issued on new insights.'),
                notifyOrderEvents: zod.boolean().optional().nullable().describe('Indicates if notification should be issued on new order events.'),
                autoRestart: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe('Indicates if the live algorithm should automatically restart after encountering runtime errors.'),
              })
              .optional()
              .nullable()
              .describe('The live wizard content used.'),
            encrypted: zod.boolean().optional().nullable().describe('Indicates if the project is encrypted.'),
            codeRunning: zod.boolean().optional().nullable().describe('Indicates if the project is running or not.'),
            leanEnvironment: zod.coerce.number().optional().nullable().describe('LEAN environment of the project running on.'),
            encryptionKey: zod
              .object({
                id: zod.string().optional().nullable().describe('Encryption key id.'),
                name: zod.string().optional().nullable().describe('Name of the encryption key.'),
              })
              .optional()
              .nullable()
              .describe('Encryption key details.'),
          })
          .describe('Response from reading a project by id.')
      )
      .optional()
      .nullable()
      .describe('List of projects for the authenticated user.'),
    versions: zod
      .array(
        zod.object({
          id: zod.coerce.number().optional().nullable().describe('Id of the LEAN version.'),
          created: zod.coerce.date().optional().nullable().describe('Date when this version was created.'),
          description: zod.string().optional().nullable().describe('Description of the LEAN version.'),
          leanHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN repository.'),
          leanCloudHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN Cloud repository.'),
          name: zod.string().optional().nullable().describe('Name of the branch where the commit is.'),
          ref: zod.string().optional().nullable().describe('Reference to the branch where the commit is.'),
          public: zod.boolean().optional().nullable().describe('Indicates if the version is available for the public.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of LEAN versions.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Project list response.')

/**
 * @summary Update a project's name or description.
 */
export const updateProjectBody = zod
  .object({
    projectId: zod.number().describe('Project Id to which the file belongs.'),
    name: zod.string().optional().nullable().describe('The new name for the project.'),
    description: zod.string().optional().nullable().describe('The new description for the project.'),
  })
  .describe("Update a project's name or description.")

export const updateProjectResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Delete a project.
 */
export const deleteProjectBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to delete.'),
  })
  .describe('Request to delete a project.')

export const deleteProjectResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Add a collaborator to a project.
 */
export const createProjectCollaborationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to add the collaborator to.'),
    collaboratorUserId: zod.string().describe('User Id of the collaborator to add.'),
    collaborationLiveControl: zod.boolean().describe('Gives the right to deploy and stop live algorithms.'),
    collaborationWrite: zod.boolean().describe('Gives the right to edit the code.'),
  })
  .describe('Request to add a new collaborator to a project.')

export const createProjectCollaborationResponse = zod
  .object({
    collaborators: zod
      .array(
        zod.object({
          uid: zod.coerce.number().optional().nullable().describe('User ID.'),
          liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
          permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
          publicId: zod.string().optional().nullable().describe('The user public ID.'),
          profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
          email: zod.string().optional().nullable().describe('The registered email of the user.'),
          name: zod.string().optional().nullable().describe('The display name of the user.'),
          bio: zod.string().optional().nullable().describe('The biography of the user.'),
          owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of collaborators.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Response received when creating collaborator.')

/**
 * @summary List all collaborators on a project.
 */
export const readProjectCollaborationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project from which to read the collaborators.'),
  })
  .describe('Request to list the collaborators in a project.')

export const readProjectCollaborationResponse = zod
  .object({
    collaborators: zod
      .array(
        zod.object({
          uid: zod.coerce.number().optional().nullable().describe('User ID.'),
          liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
          permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
          publicId: zod.string().optional().nullable().describe('The user public ID.'),
          profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
          email: zod.string().optional().nullable().describe('The registered email of the user.'),
          name: zod.string().optional().nullable().describe('The display name of the user.'),
          bio: zod.string().optional().nullable().describe('The biography of the user.'),
          owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of collaborators on the project.'),
    userLiveControl: zod.boolean().optional().nullable().describe('Indicate if the project owner has the right to deploy and stop live algorithms.'),
    userPermissions: zod.enum(['write', 'read']).optional().nullable().describe('Permissions of the project owner'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Response received when reading the collaborators of a project.')

/**
 * @summary Update collaborator information in a project.
 */
export const updateProjectCollaborationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project the collaborator is on.'),
    collaboratorUserId: zod.string().describe('User Id of the collaborator to update.'),
    liveControl: zod.boolean().describe('Gives the right to deploy and stop live algorithms.'),
    write: zod.boolean().describe('Gives the right to edit the code.'),
  })
  .describe('Request to update an existing collaborator on a project.')

export const updateProjectCollaborationResponse = zod
  .object({
    collaborators: zod
      .array(
        zod.object({
          uid: zod.coerce.number().optional().nullable().describe('User ID.'),
          liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
          permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
          publicId: zod.string().optional().nullable().describe('The user public ID.'),
          profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
          email: zod.string().optional().nullable().describe('The registered email of the user.'),
          name: zod.string().optional().nullable().describe('The display name of the user.'),
          bio: zod.string().optional().nullable().describe('The biography of the user.'),
          owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of collaborators.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Response received when updating collaborator.')

/**
 * @summary Remove a collaborator from a project.
 */
export const deleteProjectCollaborationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to remove the collaborator from.'),
    collaboratorId: zod.string().describe('User Id of the collaborator to remove.'),
  })
  .describe('Request to remove a collaborator from a project.')

export const deleteProjectCollaborationResponse = zod
  .object({
    collaborators: zod
      .array(
        zod.object({
          uid: zod.coerce.number().optional().nullable().describe('User ID.'),
          liveControl: zod.boolean().optional().nullable().describe('Indicate if the user has live control.'),
          permission: zod.enum(['read', 'write']).optional().nullable().describe('The permission this user is given.'),
          publicId: zod.string().optional().nullable().describe('The user public ID.'),
          profileImage: zod.string().optional().nullable().describe('The url of the user profile image.'),
          email: zod.string().optional().nullable().describe('The registered email of the user.'),
          name: zod.string().optional().nullable().describe('The display name of the user.'),
          bio: zod.string().optional().nullable().describe('The biography of the user.'),
          owner: zod.boolean().optional().nullable().describe('Indicate if the user is the owner of the project.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of collaborators.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Response received when removing collaborator.')

/**
 * @summary Lock a project so you can edit it. This is necessary when the project has collaborators or when an LLM is editing files on your behalf via our MCP Server.
 */
export const acquireProjectCollaborationLockBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to edit.'),
    codeSourceId: zod.string().describe("Name of the environment that's creating the request."),
  })
  .describe(
    'Lock a project so you can edit it. This is necessary when the project has collaborators or when an LLM is editing files on your behalf via our MCP Server.'
  )

export const acquireProjectCollaborationLockResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Read the available and selected nodes of a project.
 */
export const readProjectNodeBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to which the nodes refer.'),
  })
  .describe('Request to get details about the nodes in your organization, including which nodes may be used by the project.')

export const readProjectNodeResponse = zod
  .object({
    nodes: zod
      .object({
        backtest: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of backtest nodes.'),
        live: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of live nodes.'),
        research: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of research nodes.'),
      })
      .optional()
      .nullable()
      .describe('Contains sets of node lists for each target environment.'),
    autoSelectNode: zod.boolean().optional().nullable().describe('Indicate if the best-performing node is automatically selected.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when reading all nodes of a project.')

/**
 * @summary Update the active state of the given nodes to true. If you don't provide any nodes, all the nodes become inactive and autoSelectNode is true.
 */
export const updateProjectNodeBody = zod
  .object({
    projectId: zod.number().describe('Project Id to which the nodes refer.'),
    nodes: zod
      .array(zod.string())
      .optional()
      .nullable()
      .describe(
        'List of node Ids the project may use. If you omit this property or pass an empty list, the best node will be automatically selected for backtest, research, and live trading.'
      ),
  })
  .describe('Request to update the nodes of a project.')

export const updateProjectNodeResponse = zod
  .object({
    nodes: zod
      .object({
        backtest: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of backtest nodes.'),
        live: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of live nodes.'),
        research: zod
          .array(
            zod
              .object({
                speed: zod.coerce.number().optional().nullable().describe('The nodes cpu clock speed in GHz.'),
                price: zod
                  .object({
                    monthly: zod.coerce.number().optional().nullable().describe('The monthly price of the node in US dollars.'),
                    yearly: zod.coerce.number().optional().nullable().describe('The yearly price of the node in US dollars.'),
                  })
                  .optional()
                  .nullable()
                  .describe('Node prices from node object.'),
                cpu: zod.coerce.number().optional().nullable().describe('CPU core count of node.'),
                ram: zod.coerce.number().optional().nullable().describe('Size of RAM in Gigabytes.'),
                name: zod.string().optional().nullable().describe('Name of the node.'),
                sku: zod.string().optional().nullable().describe('Node type identifier for configuration.'),
                description: zod.string().optional().nullable().describe('Description of the node.'),
                usedBy: zod.string().optional().nullable().describe('User currently using the node.'),
                userProfile: zod.string().optional().nullable().describe('URL of the user using the node.'),
                projectName: zod.string().optional().nullable().describe('Project the node is being used for.'),
                projectId: zod.coerce.number().optional().nullable().describe('Id of the project the node is being used for.'),
                busy: zod.boolean().optional().nullable().describe('Indicates if the node is currently busy.'),
                id: zod.string().optional().nullable().describe('Full Id of node.'),
                assets: zod.coerce.number().optional().nullable().describe('Maximum number of assets recommended for this node.'),
                host: zod.string().optional().nullable().describe('Node host.'),
                active: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicate if this is an active node for the project. The project will use this node if it's not busy."),
                hasGpu: zod.coerce.number().optional().nullable().describe('Indicate if the node has GPU (1) or not (0).'),
              })
              .describe('Contains all relevant information on a Node to interact through API endpoints.')
          )
          .optional()
          .nullable()
          .describe('Collection of research nodes.'),
      })
      .optional()
      .nullable()
      .describe('Contains sets of node lists for each target environment.'),
    autoSelectNode: zod.boolean().optional().nullable().describe('Indicate if the best-performing node is automatically selected.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when reading all nodes of a project.')

/**
 * @summary Add a file to a given project.
 */
export const createFileBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to add the file.'),
    name: zod.string().describe('The name of the new file.'),
    content: zod.string().optional().nullable().describe('The content of the new file.'),
    codeSourceId: zod.string().optional().nullable().describe("Name of the environment that's creating the request."),
  })
  .describe('Request to add a file to a project.')

export const createFileResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary If a ReadSingleFileRequest is passed, reads that file from the project. If a ReadAllFilesRequest is passed, reads all files in the project.
 */
export const readFileBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the file.'),
    name: zod.string().optional().nullable().describe('The name of the file to read.'),
    codeSourceId: zod.string().optional().nullable().describe("Name of the environment that's creating the request."),
  })
  .describe('Request to read all files from a project or just one (if the name is provided).')

export const readFileResponse = zod
  .object({
    files: zod
      .array(
        zod
          .object({
            id: zod.coerce.number().optional().nullable().describe('ID of the project file. This can also be null.'),
            projectId: zod.coerce.number().optional().nullable().describe('ID of the project.'),
            name: zod.string().optional().nullable().describe('Name of a project file.'),
            content: zod.string().optional().nullable().describe('Contents of the project file.'),
            modified: zod.coerce.date().optional().nullable().describe('DateTime project file was modified.'),
            open: zod.boolean().optional().nullable().describe('Indicates if the project file is open or not.'),
            isLibrary: zod
              .boolean()
              .optional()
              .nullable()
              .describe("Indicates if the project file is a library or not. It's always false in live/read and backtest/read."),
          })
          .describe('File for a project.')
      )
      .optional()
      .nullable()
      .describe('List of project file information.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when creating or reading project files.')

/**
 * @summary If an UpdateProjectFileNameRequest is passed, update the name of a file. If a UpdateProjectFileContentsRequest is passed, update the contents of a file.
 */
export const updateFileBody = zod.union([
  zod
    .object({
      projectId: zod.number().describe('Id of the project that contains the file.'),
      name: zod.string().describe('The current name of the file.'),
      newName: zod.string().describe('The new name for the file.'),
      codeSourceId: zod.string().optional().nullable().describe("Name of the environment that's creating the request."),
    })
    .describe('Request to update the name of a file.'),
  zod
    .object({
      projectId: zod.number().describe('Id of the project that contains the file.'),
      name: zod.string().describe('The name of the file to update.'),
      content: zod.string().describe('The new contents of the file.'),
      codeSourceId: zod.string().optional().nullable().describe("Name of the environment that's creating the request."),
    })
    .describe('Request to update the contents of a file.'),
])

export const updateFileResponse = zod.union([
  zod
    .object({
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Base API response class for the QuantConnect API.'),
  zod
    .object({
      files: zod
        .array(
          zod
            .object({
              id: zod.coerce.number().optional().nullable().describe('ID of the project file. This can also be null.'),
              projectId: zod.coerce.number().optional().nullable().describe('ID of the project.'),
              name: zod.string().optional().nullable().describe('Name of a project file.'),
              content: zod.string().optional().nullable().describe('Contents of the project file.'),
              modified: zod.coerce.date().optional().nullable().describe('DateTime project file was modified.'),
              open: zod.boolean().optional().nullable().describe('Indicates if the project file is open or not.'),
              isLibrary: zod
                .boolean()
                .optional()
                .nullable()
                .describe("Indicates if the project file is a library or not. It's always false in live/read and backtest/read."),
            })
            .describe('File for a project.')
        )
        .optional()
        .nullable()
        .describe('List of project file information.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Response received when creating or reading project files.'),
])

/**
 * @summary Delete a file in a project.
 */
export const deleteFileBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the file.'),
    name: zod.string().describe('The name of the file to delete.'),
    codeSourceId: zod.string().optional().nullable().describe("Name of the environment that's creating the request."),
  })
  .describe('Request to delete a file in a project.')

export const deleteFileResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Asynchronously create a compile job request for a project.
 */
export const createCompileBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to compile.'),
  })
  .describe('Request to compile a project.')

export const createCompileResponse = zod
  .object({
    compileId: zod.string().optional().nullable().describe('Compile Id for a successful build.'),
    state: zod.enum(['InQueue', 'BuildSuccess', 'BuildError']).optional().nullable().describe('The current state of the compile job.'),
    parameters: zod
      .array(
        zod.object({
          file: zod.string().optional().nullable().describe('Path of the file in the project.'),
          parameters: zod
            .array(
              zod.object({
                line: zod.coerce.number().optional().nullable().describe('Line number where the parameter was detected.'),
                type: zod.string().optional().nullable().describe('Description of the detected parameter.'),
              })
            )
            .optional()
            .nullable()
            .describe('List of parameters detected in the file.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of files and their associated parameters detected during compilation.'),
    projectId: zod.coerce.number().optional().nullable().describe('Id of the project you requested to compile.'),
    signature: zod.string().optional().nullable().describe('Signature key of compilation.'),
    signatureOrder: zod.array(zod.string()).optional().nullable().describe('Signature order of files to be compiled.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received from creating a compile job.')

/**
 * @summary Read a compile packet job result.
 */
export const readCompileBody = zod
  .object({
    projectId: zod.number().describe('Id of the project you requested to compile.'),
    compileId: zod.string().describe('Compile Id returned during the creation request.'),
  })
  .describe('Request to read a compile packet job.')

export const readCompileResponse = zod
  .object({
    compileId: zod.string().optional().nullable().describe('Compile Id for a successful build.'),
    state: zod.enum(['InQueue', 'BuildSuccess', 'BuildError']).optional().nullable().describe('The current state of the compile job.'),
    logs: zod.array(zod.string()).optional().nullable().describe('Logs of the compilation request.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received from reading a compile job.')

/**
 * @summary Create a new backtest request and get the backtest Id.
 */
export const createBacktestBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to backtest.'),
    compileId: zod.string().describe('Compile Id for the project to backtest.'),
    backtestName: zod.string().describe('Name for the new backtest.'),
    parameters: zod
      .record(zod.string(), zod.union([zod.string(), zod.number(), zod.number()]))
      .optional()
      .nullable()
      .describe('Parameters to use for the backtest.'),
  })
  .describe('Request to create a new backtest.')

export const createBacktestResponse = zod
  .object({
    backtest: zod
      .object({
        note: zod.string().optional().nullable().describe('Note on the backtest attached by the user.'),
        name: zod.string().optional().nullable().describe('Name of the backtest.'),
        organizationId: zod.string().optional().nullable().describe('The Id of the orgainization.'),
        projectId: zod.coerce.number().optional().nullable().describe('Id of the project.'),
        completed: zod.boolean().optional().nullable().describe('Boolean true when the backtest is completed.'),
        optimizationId: zod.string().optional().nullable().describe('Optimization task ID, if the backtest is part of an optimization.'),
        backtestId: zod.string().optional().nullable().describe('Assigned backtest ID.'),
        tradeableDates: zod.coerce.number().optional().nullable().describe('Number of tradeable days in the backtest.'),
        researchGuide: zod
          .object({
            minutes: zod.coerce.number().optional().nullable().describe('Number of minutes used in developing the current backtest.'),
            backtestCount: zod.coerce.number().optional().nullable().describe('The quantity of backtests run in the project.'),
            parameters: zod.coerce.number().optional().nullable().describe('Number of parameters detected.'),
          })
          .optional()
          .nullable()
          .describe('A power gauge for backtests, time and parameters to estimate the overfitting risk.'),
        backtestStart: zod.coerce.date().optional().nullable().describe('The starting time of the backtest'),
        backtestEnd: zod.coerce.date().optional().nullable().describe('The ending time of the backtest'),
        created: zod.coerce.date().optional().nullable().describe('Backtest creation date and time.'),
        snapshotId: zod.coerce.number().optional().nullable().describe('Snapshot Id of this backtest result.'),
        status: zod
          .enum(['Completed.', 'In Queue...', 'In Progress...', 'Running: _%', 'Runtime Error'])
          .optional()
          .nullable()
          .describe('Status of the backtest.'),
        error: zod.string().optional().nullable().describe('Backtest error message.'),
        stacktrace: zod.string().optional().nullable().describe('Backtest error stacktrace.'),
        progress: zod.coerce.number().optional().nullable().describe('Progress of the backtest in percent 0-1.'),
        hasInitializeError: zod.boolean().optional().nullable().describe('Indicates if the backtest has error during initialization.'),
        charts: zod
          .record(
            zod.string(),
            zod
              .object({
                name: zod.string().optional().nullable().describe('Name of the Chart.'),
              })
              .describe('Contains the names of all charts')
          )
          .optional()
          .nullable()
          .describe('Charts updates for the live algorithm since the last result packet.'),
        parameterSet: zod
          .union([
            zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
            zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
          ])
          .optional()
          .nullable(),
        rollingWindow: zod
          .record(
            zod.string(),
            zod
              .object({
                tradeStatistics: zod
                  .object({
                    startDateTime: zod.coerce.date().optional().nullable().describe('The entry date/time of the first trade'),
                    endDateTime: zod.coerce.date().optional().nullable().describe('The exit date/time of the first trade.'),
                    totalNumberOfTrades: zod.coerce.number().optional().nullable().describe('The total number of trades.'),
                    numberOfWinningTrades: zod.coerce.number().optional().nullable().describe('The total number of winning trades.'),
                    numberOfLosingTrades: zod.coerce.number().optional().nullable().describe('The total number of losing trades.'),
                    totalProfitLoss: zod.coerce.number().optional().nullable().describe('The total profit/loss for all trades (as symbol currency).'),
                    totalProfit: zod.coerce.number().optional().nullable().describe('The total profit for all winning trades (as symbol currency).'),
                    totalLoss: zod.coerce.number().optional().nullable().describe('The total loss for all losing trades (as symbol currency).'),
                    largestProfit: zod.coerce.number().optional().nullable().describe('The largest profit in a single trade (as symbol currency).'),
                    largestLoss: zod.coerce.number().optional().nullable().describe('The largest loss in a single trade (as symbol currency).'),
                    averageProfitLoss: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'),
                    averageProfit: zod.coerce.number().optional().nullable().describe('The average profit for all winning trades (as symbol currency).'),
                    averageLoss: zod.coerce.number().optional().nullable().describe('The average loss for all winning trades (as symbol currency).'),
                    averageTradeDuration: zod.string().optional().nullable().describe('The average duration for all trades.'),
                    averageWinningTradeDuration: zod.string().optional().nullable().describe('The average duration for all winning trades.'),
                    averageLosingTradeDuration: zod.string().optional().nullable().describe('The average duration for all losing trades.'),
                    medianTradeDuration: zod.string().optional().nullable().describe('The median duration for all trades.'),
                    medianWinningTradeDuration: zod.string().optional().nullable().describe('The median duration for all winning trades.'),
                    medianLosingTradeDuration: zod.string().optional().nullable().describe('The median duration for all losing trades.'),
                    maxConsecutiveWinningTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive winning trades.'),
                    maxConsecutiveLosingTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive losing trades.'),
                    profitLossRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the average profit per trade to the average loss per trade.'),
                    winLossRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the number of winning trades to the number of losing trades.'),
                    winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                    lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                    averageMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                    averageMFE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                    largestMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Favorable Excursion for all trades.'),
                    largestMFE: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The largest Maximum Adverse Excursion in a single trade (as symbol currency).'),
                    maximumClosedTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum closed-trade drawdown for all trades (as symbol currency).'),
                    maximumIntraTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum intra-trade drawdown for all trades (as symbol currency).'),
                    profitLossStandardDeviation: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The standard deviation of the profits/losses for all trades (as symbol currency).'),
                    profitLossDownsideDeviation: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The downside deviation of the profits/losses for all trades (as symbol currency).'),
                    profitFactor: zod.coerce.number().optional().nullable().describe('The ratio of the total profit to the total loss.'),
                    sharpeRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the standard deviation.'),
                    sortinoRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the downside deviation.'),
                    profitToMaxDrawdownRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the total profit/loss to the maximum closed trade drawdown.'),
                    maximumEndTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum amount of profit given back by a single trade before exit (as symbol currency).'),
                    averageEndTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The average amount of profit given back by all trades before exit (as symbol currency).'),
                    maximumDrawdownDuration: zod
                      .string()
                      .optional()
                      .nullable()
                      .describe('The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'),
                    totalFees: zod.coerce.number().optional().nullable().describe('The sum of fees for all trades.'),
                  })
                  .optional()
                  .nullable()
                  .describe('A set of statistics calculated from a list of closed trades.'),
                portfolioStatistics: zod
                  .object({
                    averageWinRate: zod.coerce.number().optional().nullable().describe('The average rate of return for winning trades.'),
                    averageLossRate: zod.coerce.number().optional().nullable().describe('The average rate of return for losing trades.'),
                    profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
                    winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                    lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                    expectancy: zod.coerce.number().optional().nullable().describe('The expected value of the rate of return.'),
                    startEquity: zod.coerce.number().optional().nullable().describe('Initial Equity Total Value.'),
                    endEquity: zod.coerce.number().optional().nullable().describe('Final Equity Total Value'),
                    compoundingAnnualReturn: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
                    drawdown: zod.coerce.number().optional().nullable().describe('Drawdown maximum percentage.'),
                    totalNetProfit: zod.coerce.number().optional().nullable().describe('The total net profit percentage.'),
                    sharpeRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'),
                    probabilisticSharpeRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
                      ),
                    sortinoRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
                    alpha: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        "Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."
                      ),
                    beta: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'),
                    annualStandardDeviation: zod.coerce.number().optional().nullable().describe('Annualized standard deviation'),
                    annualVariance: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
                    informationRatio: zod.coerce.number().optional().nullable().describe('Information ratio - risk adjusted return.'),
                    trackingError: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'
                      ),
                    treynorRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
                      ),
                    portfolioTurnover: zod.coerce.number().optional().nullable().describe('The average Portfolio Turnover.'),
                    valueAtRisk99: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                      ),
                    valueAtRisk95: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                      ),
                  })
                  .optional()
                  .nullable()
                  .describe('Represents a set of statistics calculated from equity and benchmark samples.'),
                closedTrades: zod
                  .array(
                    zod
                      .object({
                        symbol: zod
                          .object({
                            value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                            id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                            permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
                          })
                          .optional()
                          .nullable()
                          .describe(
                            'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
                          ),
                        entryTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was opened.'),
                        entryPrice: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The price at which the trade was opened (or the average price if multiple entries).'),
                        direction: zod
                          .union([zod.literal(0), zod.literal(1)])
                          .optional()
                          .nullable()
                          .describe('Direction of a trade. 0=Long, 1=Short.'),
                        quantity: zod.coerce.number().optional().nullable().describe('The total unsigned quantity of the trade.'),
                        exitTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was closed.'),
                        exitPrice: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The price at which the trade was closed (or the average price if multiple exits).'),
                        profitLoss: zod.coerce.number().optional().nullable().describe('The gross profit/loss of the trade (as account currency).'),
                        totalFees: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The total fees associated with the trade (always positive value) (as account currency).'),
                        mae: zod.coerce.number().optional().nullable().describe('The Maximum Adverse Excursion (as account currency).'),
                        mfe: zod.coerce.number().optional().nullable().describe('The Maximum Favorable Excursion (as account currency).'),
                        duration: zod.string().optional().nullable().describe('The duration of the trade.'),
                        endTradeDrawdown: zod.coerce.number().optional().nullable().describe('The amount of profit given back before the trade was closed.'),
                      })
                      .describe('Represents a closed trade.')
                  )
                  .optional()
                  .nullable()
                  .describe('The algorithm statistics on portfolio.'),
              })
              .describe('The AlgorithmPerformance class is a wrapper for TradeStatistics and PortfolioStatistics.')
          )
          .optional()
          .nullable()
          .describe('Rolling window detailed statistics.'),
        runtimeStatistics: zod
          .object({
            Equity: zod.string().optional().nullable().describe('Total portfolio value.'),
            Fees: zod.string().optional().nullable().describe('Transaction fee.'),
            Holdings: zod.string().optional().nullable().describe('Equity value of security holdings.'),
            'Net Profit': zod.string().optional().nullable().describe('Net profit.'),
            'Probabilistic Sharpe Ratio': zod.string().optional().nullable().describe('Probabilistic Sharpe Ratio.'),
            Return: zod.string().optional().nullable().describe('Return.'),
            Unrealized: zod.string().optional().nullable().describe('Unrealized profit/loss.'),
            Volume: zod.string().optional().nullable().describe('Total transaction volume.'),
          })
          .optional()
          .nullable(),
        statistics: zod
          .object({
            'Total Orders': zod.string().optional().nullable().describe('Total nuber of orders.'),
            'Average Win': zod.string().optional().nullable().describe('The average rate of return for winning trades.'),
            'Average Loss': zod.string().optional().nullable().describe('The average rate of return for losing trades.'),
            'Compounding Annual Return': zod
              .string()
              .optional()
              .nullable()
              .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
            Drawdown: zod.string().optional().nullable().describe('Drawdown maximum percentage.'),
            Expectancy: zod.string().optional().nullable().describe('The expected value of the rate of return.'),
            'Start Equity': zod.string().optional().nullable().describe('Initial Equity Total Value.'),
            'End Equity': zod.string().optional().nullable().describe('Final Equity Total Value.'),
            'Net Profit': zod.string().optional().nullable().describe('The total net profit percentage.'),
            'Sharpe Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe('Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.'),
            'Sortino Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
            'Probabilistic Sharpe Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe(
                'Is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
              ),
            'Loss Rate': zod.string().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
            'Win Rate': zod.string().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
            'Profit-Loss Ratio': zod.string().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
            Alpha: zod
              .string()
              .optional()
              .nullable()
              .describe("Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."),
            Beta: zod
              .string()
              .optional()
              .nullable()
              .describe("Algorithm 'beta' statistic - the covariance between the algorithm and benchmark performance, divided by benchmark's variance."),
            'Annual Standard Deviation': zod.string().optional().nullable().describe('Annualized standard deviation.'),
            'Annual Variance': zod
              .string()
              .optional()
              .nullable()
              .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
            'Information Ratio': zod.string().optional().nullable().describe('Information ratio - risk adjusted return.'),
            'Tracking Error': zod
              .string()
              .optional()
              .nullable()
              .describe('Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'),
            'Treynor Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe(
                'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
              ),
            'Total Fees': zod.string().optional().nullable().describe('Total amount of fees.'),
            'Estimated Strategy Capacity': zod.string().optional().nullable().describe('The estimated total capacity of the strategy at a point in time.'),
            'Lowest Capacity Asset': zod
              .string()
              .optional()
              .nullable()
              .describe('Provide a reference to the lowest capacity symbol used in scaling down the capacity for debugging.'),
            'Portfolio Turnover': zod.string().optional().nullable().describe('The average Portfolio Turnover'),
          })
          .optional()
          .nullable()
          .describe('Statistics information sent during the algorithm operations.'),
        totalPerformance: zod
          .object({
            tradeStatistics: zod
              .object({
                startDateTime: zod.coerce.date().optional().nullable().describe('The entry date/time of the first trade'),
                endDateTime: zod.coerce.date().optional().nullable().describe('The exit date/time of the first trade.'),
                totalNumberOfTrades: zod.coerce.number().optional().nullable().describe('The total number of trades.'),
                numberOfWinningTrades: zod.coerce.number().optional().nullable().describe('The total number of winning trades.'),
                numberOfLosingTrades: zod.coerce.number().optional().nullable().describe('The total number of losing trades.'),
                totalProfitLoss: zod.coerce.number().optional().nullable().describe('The total profit/loss for all trades (as symbol currency).'),
                totalProfit: zod.coerce.number().optional().nullable().describe('The total profit for all winning trades (as symbol currency).'),
                totalLoss: zod.coerce.number().optional().nullable().describe('The total loss for all losing trades (as symbol currency).'),
                largestProfit: zod.coerce.number().optional().nullable().describe('The largest profit in a single trade (as symbol currency).'),
                largestLoss: zod.coerce.number().optional().nullable().describe('The largest loss in a single trade (as symbol currency).'),
                averageProfitLoss: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'),
                averageProfit: zod.coerce.number().optional().nullable().describe('The average profit for all winning trades (as symbol currency).'),
                averageLoss: zod.coerce.number().optional().nullable().describe('The average loss for all winning trades (as symbol currency).'),
                averageTradeDuration: zod.string().optional().nullable().describe('The average duration for all trades.'),
                averageWinningTradeDuration: zod.string().optional().nullable().describe('The average duration for all winning trades.'),
                averageLosingTradeDuration: zod.string().optional().nullable().describe('The average duration for all losing trades.'),
                medianTradeDuration: zod.string().optional().nullable().describe('The median duration for all trades.'),
                medianWinningTradeDuration: zod.string().optional().nullable().describe('The median duration for all winning trades.'),
                medianLosingTradeDuration: zod.string().optional().nullable().describe('The median duration for all losing trades.'),
                maxConsecutiveWinningTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive winning trades.'),
                maxConsecutiveLosingTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive losing trades.'),
                profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit per trade to the average loss per trade.'),
                winLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the number of losing trades.'),
                winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                averageMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                averageMFE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                largestMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Favorable Excursion for all trades.'),
                largestMFE: zod.coerce.number().optional().nullable().describe('The largest Maximum Adverse Excursion in a single trade (as symbol currency).'),
                maximumClosedTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum closed-trade drawdown for all trades (as symbol currency).'),
                maximumIntraTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum intra-trade drawdown for all trades (as symbol currency).'),
                profitLossStandardDeviation: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The standard deviation of the profits/losses for all trades (as symbol currency).'),
                profitLossDownsideDeviation: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The downside deviation of the profits/losses for all trades (as symbol currency).'),
                profitFactor: zod.coerce.number().optional().nullable().describe('The ratio of the total profit to the total loss.'),
                sharpeRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the standard deviation.'),
                sortinoRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the downside deviation.'),
                profitToMaxDrawdownRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The ratio of the total profit/loss to the maximum closed trade drawdown.'),
                maximumEndTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum amount of profit given back by a single trade before exit (as symbol currency).'),
                averageEndTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The average amount of profit given back by all trades before exit (as symbol currency).'),
                maximumDrawdownDuration: zod
                  .string()
                  .optional()
                  .nullable()
                  .describe('The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'),
                totalFees: zod.coerce.number().optional().nullable().describe('The sum of fees for all trades.'),
              })
              .optional()
              .nullable()
              .describe('A set of statistics calculated from a list of closed trades.'),
            portfolioStatistics: zod
              .object({
                averageWinRate: zod.coerce.number().optional().nullable().describe('The average rate of return for winning trades.'),
                averageLossRate: zod.coerce.number().optional().nullable().describe('The average rate of return for losing trades.'),
                profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
                winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                expectancy: zod.coerce.number().optional().nullable().describe('The expected value of the rate of return.'),
                startEquity: zod.coerce.number().optional().nullable().describe('Initial Equity Total Value.'),
                endEquity: zod.coerce.number().optional().nullable().describe('Final Equity Total Value'),
                compoundingAnnualReturn: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
                drawdown: zod.coerce.number().optional().nullable().describe('Drawdown maximum percentage.'),
                totalNetProfit: zod.coerce.number().optional().nullable().describe('The total net profit percentage.'),
                sharpeRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'),
                probabilisticSharpeRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
                  ),
                sortinoRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
                alpha: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe("Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."),
                beta: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'),
                annualStandardDeviation: zod.coerce.number().optional().nullable().describe('Annualized standard deviation'),
                annualVariance: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
                informationRatio: zod.coerce.number().optional().nullable().describe('Information ratio - risk adjusted return.'),
                trackingError: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'),
                treynorRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
                  ),
                portfolioTurnover: zod.coerce.number().optional().nullable().describe('The average Portfolio Turnover.'),
                valueAtRisk99: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                  ),
                valueAtRisk95: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                  ),
              })
              .optional()
              .nullable()
              .describe('Represents a set of statistics calculated from equity and benchmark samples.'),
            closedTrades: zod
              .array(
                zod
                  .object({
                    symbol: zod
                      .object({
                        value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                        id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                        permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
                      })
                      .optional()
                      .nullable()
                      .describe(
                        'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
                      ),
                    entryTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was opened.'),
                    entryPrice: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The price at which the trade was opened (or the average price if multiple entries).'),
                    direction: zod
                      .union([zod.literal(0), zod.literal(1)])
                      .optional()
                      .nullable()
                      .describe('Direction of a trade. 0=Long, 1=Short.'),
                    quantity: zod.coerce.number().optional().nullable().describe('The total unsigned quantity of the trade.'),
                    exitTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was closed.'),
                    exitPrice: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The price at which the trade was closed (or the average price if multiple exits).'),
                    profitLoss: zod.coerce.number().optional().nullable().describe('The gross profit/loss of the trade (as account currency).'),
                    totalFees: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The total fees associated with the trade (always positive value) (as account currency).'),
                    mae: zod.coerce.number().optional().nullable().describe('The Maximum Adverse Excursion (as account currency).'),
                    mfe: zod.coerce.number().optional().nullable().describe('The Maximum Favorable Excursion (as account currency).'),
                    duration: zod.string().optional().nullable().describe('The duration of the trade.'),
                    endTradeDrawdown: zod.coerce.number().optional().nullable().describe('The amount of profit given back before the trade was closed.'),
                  })
                  .describe('Represents a closed trade.')
              )
              .optional()
              .nullable()
              .describe('The algorithm statistics on portfolio.'),
          })
          .optional()
          .nullable()
          .describe('The AlgorithmPerformance class is a wrapper for TradeStatistics and PortfolioStatistics.'),
        nodeName: zod.string().optional().nullable().describe('The backtest node name.'),
        outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out of sample data.'),
        outOfSampleDays: zod.coerce.number().optional().nullable().describe('Number of days of out of sample days.'),
      })
      .optional()
      .nullable()
      .describe('Results object class. Results are exhaust from backtest or live algorithms running in LEAN.'),
    debugging: zod.boolean().optional().nullable().describe('Indicates if the backtest is run under debugging mode.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Collection container for a list of backtests for a project.')

/**
 * @summary Read the results of a backtest.
 */
export const readBacktestBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the backtest.'),
    backtestId: zod.string().describe('Id of the backtest to read.'),
  })
  .describe('Request to read a single backtest from a project.')

export const readBacktestResponse = zod
  .object({
    backtest: zod
      .object({
        note: zod.string().optional().nullable().describe('Note on the backtest attached by the user.'),
        name: zod.string().optional().nullable().describe('Name of the backtest.'),
        organizationId: zod.string().optional().nullable().describe('The Id of the orgainization.'),
        projectId: zod.coerce.number().optional().nullable().describe('Id of the project.'),
        completed: zod.boolean().optional().nullable().describe('Boolean true when the backtest is completed.'),
        optimizationId: zod.string().optional().nullable().describe('Optimization task ID, if the backtest is part of an optimization.'),
        backtestId: zod.string().optional().nullable().describe('Assigned backtest ID.'),
        tradeableDates: zod.coerce.number().optional().nullable().describe('Number of tradeable days in the backtest.'),
        researchGuide: zod
          .object({
            minutes: zod.coerce.number().optional().nullable().describe('Number of minutes used in developing the current backtest.'),
            backtestCount: zod.coerce.number().optional().nullable().describe('The quantity of backtests run in the project.'),
            parameters: zod.coerce.number().optional().nullable().describe('Number of parameters detected.'),
          })
          .optional()
          .nullable()
          .describe('A power gauge for backtests, time and parameters to estimate the overfitting risk.'),
        backtestStart: zod.coerce.date().optional().nullable().describe('The starting time of the backtest'),
        backtestEnd: zod.coerce.date().optional().nullable().describe('The ending time of the backtest'),
        created: zod.coerce.date().optional().nullable().describe('Backtest creation date and time.'),
        snapshotId: zod.coerce.number().optional().nullable().describe('Snapshot Id of this backtest result.'),
        status: zod
          .enum(['Completed.', 'In Queue...', 'In Progress...', 'Running: _%', 'Runtime Error'])
          .optional()
          .nullable()
          .describe('Status of the backtest.'),
        error: zod.string().optional().nullable().describe('Backtest error message.'),
        stacktrace: zod.string().optional().nullable().describe('Backtest error stacktrace.'),
        progress: zod.coerce.number().optional().nullable().describe('Progress of the backtest in percent 0-1.'),
        hasInitializeError: zod.boolean().optional().nullable().describe('Indicates if the backtest has error during initialization.'),
        charts: zod
          .record(
            zod.string(),
            zod
              .object({
                name: zod.string().optional().nullable().describe('Name of the Chart.'),
              })
              .describe('Contains the names of all charts')
          )
          .optional()
          .nullable()
          .describe('Charts updates for the live algorithm since the last result packet.'),
        parameterSet: zod
          .union([
            zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
            zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
          ])
          .optional()
          .nullable(),
        rollingWindow: zod
          .record(
            zod.string(),
            zod
              .object({
                tradeStatistics: zod
                  .object({
                    startDateTime: zod.coerce.date().optional().nullable().describe('The entry date/time of the first trade'),
                    endDateTime: zod.coerce.date().optional().nullable().describe('The exit date/time of the first trade.'),
                    totalNumberOfTrades: zod.coerce.number().optional().nullable().describe('The total number of trades.'),
                    numberOfWinningTrades: zod.coerce.number().optional().nullable().describe('The total number of winning trades.'),
                    numberOfLosingTrades: zod.coerce.number().optional().nullable().describe('The total number of losing trades.'),
                    totalProfitLoss: zod.coerce.number().optional().nullable().describe('The total profit/loss for all trades (as symbol currency).'),
                    totalProfit: zod.coerce.number().optional().nullable().describe('The total profit for all winning trades (as symbol currency).'),
                    totalLoss: zod.coerce.number().optional().nullable().describe('The total loss for all losing trades (as symbol currency).'),
                    largestProfit: zod.coerce.number().optional().nullable().describe('The largest profit in a single trade (as symbol currency).'),
                    largestLoss: zod.coerce.number().optional().nullable().describe('The largest loss in a single trade (as symbol currency).'),
                    averageProfitLoss: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'),
                    averageProfit: zod.coerce.number().optional().nullable().describe('The average profit for all winning trades (as symbol currency).'),
                    averageLoss: zod.coerce.number().optional().nullable().describe('The average loss for all winning trades (as symbol currency).'),
                    averageTradeDuration: zod.string().optional().nullable().describe('The average duration for all trades.'),
                    averageWinningTradeDuration: zod.string().optional().nullable().describe('The average duration for all winning trades.'),
                    averageLosingTradeDuration: zod.string().optional().nullable().describe('The average duration for all losing trades.'),
                    medianTradeDuration: zod.string().optional().nullable().describe('The median duration for all trades.'),
                    medianWinningTradeDuration: zod.string().optional().nullable().describe('The median duration for all winning trades.'),
                    medianLosingTradeDuration: zod.string().optional().nullable().describe('The median duration for all losing trades.'),
                    maxConsecutiveWinningTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive winning trades.'),
                    maxConsecutiveLosingTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive losing trades.'),
                    profitLossRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the average profit per trade to the average loss per trade.'),
                    winLossRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the number of winning trades to the number of losing trades.'),
                    winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                    lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                    averageMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                    averageMFE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                    largestMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Favorable Excursion for all trades.'),
                    largestMFE: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The largest Maximum Adverse Excursion in a single trade (as symbol currency).'),
                    maximumClosedTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum closed-trade drawdown for all trades (as symbol currency).'),
                    maximumIntraTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum intra-trade drawdown for all trades (as symbol currency).'),
                    profitLossStandardDeviation: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The standard deviation of the profits/losses for all trades (as symbol currency).'),
                    profitLossDownsideDeviation: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The downside deviation of the profits/losses for all trades (as symbol currency).'),
                    profitFactor: zod.coerce.number().optional().nullable().describe('The ratio of the total profit to the total loss.'),
                    sharpeRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the standard deviation.'),
                    sortinoRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the downside deviation.'),
                    profitToMaxDrawdownRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The ratio of the total profit/loss to the maximum closed trade drawdown.'),
                    maximumEndTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The maximum amount of profit given back by a single trade before exit (as symbol currency).'),
                    averageEndTradeDrawdown: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The average amount of profit given back by all trades before exit (as symbol currency).'),
                    maximumDrawdownDuration: zod
                      .string()
                      .optional()
                      .nullable()
                      .describe('The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'),
                    totalFees: zod.coerce.number().optional().nullable().describe('The sum of fees for all trades.'),
                  })
                  .optional()
                  .nullable()
                  .describe('A set of statistics calculated from a list of closed trades.'),
                portfolioStatistics: zod
                  .object({
                    averageWinRate: zod.coerce.number().optional().nullable().describe('The average rate of return for winning trades.'),
                    averageLossRate: zod.coerce.number().optional().nullable().describe('The average rate of return for losing trades.'),
                    profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
                    winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                    lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                    expectancy: zod.coerce.number().optional().nullable().describe('The expected value of the rate of return.'),
                    startEquity: zod.coerce.number().optional().nullable().describe('Initial Equity Total Value.'),
                    endEquity: zod.coerce.number().optional().nullable().describe('Final Equity Total Value'),
                    compoundingAnnualReturn: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
                    drawdown: zod.coerce.number().optional().nullable().describe('Drawdown maximum percentage.'),
                    totalNetProfit: zod.coerce.number().optional().nullable().describe('The total net profit percentage.'),
                    sharpeRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'),
                    probabilisticSharpeRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
                      ),
                    sortinoRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
                    alpha: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        "Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."
                      ),
                    beta: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'),
                    annualStandardDeviation: zod.coerce.number().optional().nullable().describe('Annualized standard deviation'),
                    annualVariance: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
                    informationRatio: zod.coerce.number().optional().nullable().describe('Information ratio - risk adjusted return.'),
                    trackingError: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'
                      ),
                    treynorRatio: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
                      ),
                    portfolioTurnover: zod.coerce.number().optional().nullable().describe('The average Portfolio Turnover.'),
                    valueAtRisk99: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                      ),
                    valueAtRisk95: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe(
                        'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                      ),
                  })
                  .optional()
                  .nullable()
                  .describe('Represents a set of statistics calculated from equity and benchmark samples.'),
                closedTrades: zod
                  .array(
                    zod
                      .object({
                        symbol: zod
                          .object({
                            value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                            id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                            permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
                          })
                          .optional()
                          .nullable()
                          .describe(
                            'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
                          ),
                        entryTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was opened.'),
                        entryPrice: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The price at which the trade was opened (or the average price if multiple entries).'),
                        direction: zod
                          .union([zod.literal(0), zod.literal(1)])
                          .optional()
                          .nullable()
                          .describe('Direction of a trade. 0=Long, 1=Short.'),
                        quantity: zod.coerce.number().optional().nullable().describe('The total unsigned quantity of the trade.'),
                        exitTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was closed.'),
                        exitPrice: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The price at which the trade was closed (or the average price if multiple exits).'),
                        profitLoss: zod.coerce.number().optional().nullable().describe('The gross profit/loss of the trade (as account currency).'),
                        totalFees: zod.coerce
                          .number()
                          .optional()
                          .nullable()
                          .describe('The total fees associated with the trade (always positive value) (as account currency).'),
                        mae: zod.coerce.number().optional().nullable().describe('The Maximum Adverse Excursion (as account currency).'),
                        mfe: zod.coerce.number().optional().nullable().describe('The Maximum Favorable Excursion (as account currency).'),
                        duration: zod.string().optional().nullable().describe('The duration of the trade.'),
                        endTradeDrawdown: zod.coerce.number().optional().nullable().describe('The amount of profit given back before the trade was closed.'),
                      })
                      .describe('Represents a closed trade.')
                  )
                  .optional()
                  .nullable()
                  .describe('The algorithm statistics on portfolio.'),
              })
              .describe('The AlgorithmPerformance class is a wrapper for TradeStatistics and PortfolioStatistics.')
          )
          .optional()
          .nullable()
          .describe('Rolling window detailed statistics.'),
        runtimeStatistics: zod
          .object({
            Equity: zod.string().optional().nullable().describe('Total portfolio value.'),
            Fees: zod.string().optional().nullable().describe('Transaction fee.'),
            Holdings: zod.string().optional().nullable().describe('Equity value of security holdings.'),
            'Net Profit': zod.string().optional().nullable().describe('Net profit.'),
            'Probabilistic Sharpe Ratio': zod.string().optional().nullable().describe('Probabilistic Sharpe Ratio.'),
            Return: zod.string().optional().nullable().describe('Return.'),
            Unrealized: zod.string().optional().nullable().describe('Unrealized profit/loss.'),
            Volume: zod.string().optional().nullable().describe('Total transaction volume.'),
          })
          .optional()
          .nullable(),
        statistics: zod
          .object({
            'Total Orders': zod.string().optional().nullable().describe('Total nuber of orders.'),
            'Average Win': zod.string().optional().nullable().describe('The average rate of return for winning trades.'),
            'Average Loss': zod.string().optional().nullable().describe('The average rate of return for losing trades.'),
            'Compounding Annual Return': zod
              .string()
              .optional()
              .nullable()
              .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
            Drawdown: zod.string().optional().nullable().describe('Drawdown maximum percentage.'),
            Expectancy: zod.string().optional().nullable().describe('The expected value of the rate of return.'),
            'Start Equity': zod.string().optional().nullable().describe('Initial Equity Total Value.'),
            'End Equity': zod.string().optional().nullable().describe('Final Equity Total Value.'),
            'Net Profit': zod.string().optional().nullable().describe('The total net profit percentage.'),
            'Sharpe Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe('Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.'),
            'Sortino Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
            'Probabilistic Sharpe Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe(
                'Is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
              ),
            'Loss Rate': zod.string().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
            'Win Rate': zod.string().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
            'Profit-Loss Ratio': zod.string().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
            Alpha: zod
              .string()
              .optional()
              .nullable()
              .describe("Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."),
            Beta: zod
              .string()
              .optional()
              .nullable()
              .describe("Algorithm 'beta' statistic - the covariance between the algorithm and benchmark performance, divided by benchmark's variance."),
            'Annual Standard Deviation': zod.string().optional().nullable().describe('Annualized standard deviation.'),
            'Annual Variance': zod
              .string()
              .optional()
              .nullable()
              .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
            'Information Ratio': zod.string().optional().nullable().describe('Information ratio - risk adjusted return.'),
            'Tracking Error': zod
              .string()
              .optional()
              .nullable()
              .describe('Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'),
            'Treynor Ratio': zod
              .string()
              .optional()
              .nullable()
              .describe(
                'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
              ),
            'Total Fees': zod.string().optional().nullable().describe('Total amount of fees.'),
            'Estimated Strategy Capacity': zod.string().optional().nullable().describe('The estimated total capacity of the strategy at a point in time.'),
            'Lowest Capacity Asset': zod
              .string()
              .optional()
              .nullable()
              .describe('Provide a reference to the lowest capacity symbol used in scaling down the capacity for debugging.'),
            'Portfolio Turnover': zod.string().optional().nullable().describe('The average Portfolio Turnover'),
          })
          .optional()
          .nullable()
          .describe('Statistics information sent during the algorithm operations.'),
        totalPerformance: zod
          .object({
            tradeStatistics: zod
              .object({
                startDateTime: zod.coerce.date().optional().nullable().describe('The entry date/time of the first trade'),
                endDateTime: zod.coerce.date().optional().nullable().describe('The exit date/time of the first trade.'),
                totalNumberOfTrades: zod.coerce.number().optional().nullable().describe('The total number of trades.'),
                numberOfWinningTrades: zod.coerce.number().optional().nullable().describe('The total number of winning trades.'),
                numberOfLosingTrades: zod.coerce.number().optional().nullable().describe('The total number of losing trades.'),
                totalProfitLoss: zod.coerce.number().optional().nullable().describe('The total profit/loss for all trades (as symbol currency).'),
                totalProfit: zod.coerce.number().optional().nullable().describe('The total profit for all winning trades (as symbol currency).'),
                totalLoss: zod.coerce.number().optional().nullable().describe('The total loss for all losing trades (as symbol currency).'),
                largestProfit: zod.coerce.number().optional().nullable().describe('The largest profit in a single trade (as symbol currency).'),
                largestLoss: zod.coerce.number().optional().nullable().describe('The largest loss in a single trade (as symbol currency).'),
                averageProfitLoss: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The average profit/loss (a.k.a. Expectancy or Average Trade) for all trades (as symbol currency).'),
                averageProfit: zod.coerce.number().optional().nullable().describe('The average profit for all winning trades (as symbol currency).'),
                averageLoss: zod.coerce.number().optional().nullable().describe('The average loss for all winning trades (as symbol currency).'),
                averageTradeDuration: zod.string().optional().nullable().describe('The average duration for all trades.'),
                averageWinningTradeDuration: zod.string().optional().nullable().describe('The average duration for all winning trades.'),
                averageLosingTradeDuration: zod.string().optional().nullable().describe('The average duration for all losing trades.'),
                medianTradeDuration: zod.string().optional().nullable().describe('The median duration for all trades.'),
                medianWinningTradeDuration: zod.string().optional().nullable().describe('The median duration for all winning trades.'),
                medianLosingTradeDuration: zod.string().optional().nullable().describe('The median duration for all losing trades.'),
                maxConsecutiveWinningTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive winning trades.'),
                maxConsecutiveLosingTrades: zod.coerce.number().optional().nullable().describe('The maximum number of consecutive losing trades.'),
                profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit per trade to the average loss per trade.'),
                winLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the number of losing trades.'),
                winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                averageMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                averageMFE: zod.coerce.number().optional().nullable().describe('The average Maximum Adverse Excursion for all trades.'),
                largestMAE: zod.coerce.number().optional().nullable().describe('The average Maximum Favorable Excursion for all trades.'),
                largestMFE: zod.coerce.number().optional().nullable().describe('The largest Maximum Adverse Excursion in a single trade (as symbol currency).'),
                maximumClosedTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum closed-trade drawdown for all trades (as symbol currency).'),
                maximumIntraTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum intra-trade drawdown for all trades (as symbol currency).'),
                profitLossStandardDeviation: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The standard deviation of the profits/losses for all trades (as symbol currency).'),
                profitLossDownsideDeviation: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The downside deviation of the profits/losses for all trades (as symbol currency).'),
                profitFactor: zod.coerce.number().optional().nullable().describe('The ratio of the total profit to the total loss.'),
                sharpeRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the standard deviation.'),
                sortinoRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average profit/loss to the downside deviation.'),
                profitToMaxDrawdownRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The ratio of the total profit/loss to the maximum closed trade drawdown.'),
                maximumEndTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The maximum amount of profit given back by a single trade before exit (as symbol currency).'),
                averageEndTradeDrawdown: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('The average amount of profit given back by all trades before exit (as symbol currency).'),
                maximumDrawdownDuration: zod
                  .string()
                  .optional()
                  .nullable()
                  .describe('The maximum amount of time to recover from a drawdown (longest time between new equity highs or peaks).'),
                totalFees: zod.coerce.number().optional().nullable().describe('The sum of fees for all trades.'),
              })
              .optional()
              .nullable()
              .describe('A set of statistics calculated from a list of closed trades.'),
            portfolioStatistics: zod
              .object({
                averageWinRate: zod.coerce.number().optional().nullable().describe('The average rate of return for winning trades.'),
                averageLossRate: zod.coerce.number().optional().nullable().describe('The average rate of return for losing trades.'),
                profitLossRatio: zod.coerce.number().optional().nullable().describe('The ratio of the average win rate to the average loss rate.'),
                winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
                lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
                expectancy: zod.coerce.number().optional().nullable().describe('The expected value of the rate of return.'),
                startEquity: zod.coerce.number().optional().nullable().describe('Initial Equity Total Value.'),
                endEquity: zod.coerce.number().optional().nullable().describe('Final Equity Total Value'),
                compoundingAnnualReturn: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
                drawdown: zod.coerce.number().optional().nullable().describe('Drawdown maximum percentage.'),
                totalNetProfit: zod.coerce.number().optional().nullable().describe('The total net profit percentage.'),
                sharpeRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Sharpe ratio with respect to risk free rate: measures excess of return per unit of risk.'),
                probabilisticSharpeRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'Probabilistic Sharpe Ratio is a probability measure associated with the Sharpe ratio. It informs us of the probability that the estimated Sharpe ratio is greater than a chosen benchmark.'
                  ),
                sortinoRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
                alpha: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe("Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."),
                beta: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Algorithm beta statistic - the covariance between the algorithm and benchmark performance, divided by benchmark variance.'),
                annualStandardDeviation: zod.coerce.number().optional().nullable().describe('Annualized standard deviation'),
                annualVariance: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Annualized variance statistic calculation using the daily performance variance and trading days per year.'),
                informationRatio: zod.coerce.number().optional().nullable().describe('Information ratio - risk adjusted return.'),
                trackingError: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe('Tracking error volatility (TEV) statistic - a measure of how closely a portfolio follows the index to which it is benchmarked.'),
                treynorRatio: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
                  ),
                portfolioTurnover: zod.coerce.number().optional().nullable().describe('The average Portfolio Turnover.'),
                valueAtRisk99: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 99% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                  ),
                valueAtRisk95: zod.coerce
                  .number()
                  .optional()
                  .nullable()
                  .describe(
                    'The 1-day VaR for the portfolio, using the Variance-covariance approach. Assumes a 95% confidence level, 1 year lookback period, and that the returns are normally distributed.'
                  ),
              })
              .optional()
              .nullable()
              .describe('Represents a set of statistics calculated from equity and benchmark samples.'),
            closedTrades: zod
              .array(
                zod
                  .object({
                    symbol: zod
                      .object({
                        value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                        id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                        permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
                      })
                      .optional()
                      .nullable()
                      .describe(
                        'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
                      ),
                    entryTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was opened.'),
                    entryPrice: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The price at which the trade was opened (or the average price if multiple entries).'),
                    direction: zod
                      .union([zod.literal(0), zod.literal(1)])
                      .optional()
                      .nullable()
                      .describe('Direction of a trade. 0=Long, 1=Short.'),
                    quantity: zod.coerce.number().optional().nullable().describe('The total unsigned quantity of the trade.'),
                    exitTime: zod.coerce.date().optional().nullable().describe('The date and time the trade was closed.'),
                    exitPrice: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The price at which the trade was closed (or the average price if multiple exits).'),
                    profitLoss: zod.coerce.number().optional().nullable().describe('The gross profit/loss of the trade (as account currency).'),
                    totalFees: zod.coerce
                      .number()
                      .optional()
                      .nullable()
                      .describe('The total fees associated with the trade (always positive value) (as account currency).'),
                    mae: zod.coerce.number().optional().nullable().describe('The Maximum Adverse Excursion (as account currency).'),
                    mfe: zod.coerce.number().optional().nullable().describe('The Maximum Favorable Excursion (as account currency).'),
                    duration: zod.string().optional().nullable().describe('The duration of the trade.'),
                    endTradeDrawdown: zod.coerce.number().optional().nullable().describe('The amount of profit given back before the trade was closed.'),
                  })
                  .describe('Represents a closed trade.')
              )
              .optional()
              .nullable()
              .describe('The algorithm statistics on portfolio.'),
          })
          .optional()
          .nullable()
          .describe('The AlgorithmPerformance class is a wrapper for TradeStatistics and PortfolioStatistics.'),
        nodeName: zod.string().optional().nullable().describe('The backtest node name.'),
        outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out of sample data.'),
        outOfSampleDays: zod.coerce.number().optional().nullable().describe('Number of days of out of sample days.'),
      })
      .optional()
      .nullable()
      .describe('Results object class. Results are exhaust from backtest or live algorithms running in LEAN.'),
    debugging: zod.boolean().optional().nullable().describe('Indicates if the backtest is run under debugging mode.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Collection container for a list of backtests for a project.')

/**
 * @summary List all the backtests for a project.
 */
export const listBacktestsBodyIncludeStatisticsDefault = false

export const listBacktestsBody = zod
  .object({
    projectId: zod.number().describe('Id of the project from which to read one or multiple backtests.'),
    includeStatistics: zod
      .boolean()
      .optional()
      .nullable()
      .describe('If true, the backtests summaries from the response will contain the statistics with their corresponding values.'),
  })
  .describe('Request to list the backtests from a project.')

export const listBacktestsResponse = zod
  .object({
    backtests: zod
      .array(
        zod
          .object({
            backtestId: zod.string().optional().nullable().describe('Assigned backtest ID'),
            status: zod
              .enum(['Completed.', 'In Queue...', 'In Progress...', 'Running: _%', 'Runtime Error'])
              .optional()
              .nullable()
              .describe('Status of the backtest.'),
            name: zod.string().optional().nullable().describe('Name of the backtest.'),
            created: zod.coerce.date().optional().nullable().describe('Backtest creation date and time.'),
            progress: zod.coerce.number().optional().nullable().describe('Progress of the backtest in percent 0-1.'),
            optimizationId: zod.string().optional().nullable().describe('Optimization task ID, if the backtest is part of an optimization.'),
            tradeableDates: zod.coerce.number().optional().nullable().describe('Number of traadeable days'),
            parameterSet: zod
              .union([
                zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
                zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
              ])
              .optional()
              .nullable(),
            snapshotId: zod.coerce.number().optional().nullable().describe('Snapshot id of this backtest result.'),
            tags: zod.array(zod.string()).optional().nullable().describe('Collection of tags for the backtest.'),
            sharpeRatio: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Sharpe ratio with respect to risk free rate; measures excess of return per unit of risk.'),
            alpha: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe("Algorithm 'Alpha' statistic - abnormal returns over the risk free rate and the relationshio (beta) with the benchmark returns."),
            beta: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe("Algorithm 'beta' statistic - the covariance between the algorithm and benchmark performance, divided by benchmark's variance."),
            compoundingAnnualReturn: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Annual compounded returns statistic based on the final-starting capital and years.'),
            drawdown: zod.coerce.number().optional().nullable().describe('Drawdown maximum percentage.'),
            lossRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of losing trades to the total number of trades.'),
            netProfit: zod.coerce.number().optional().nullable().describe('Net profit percentage.'),
            parameters: zod.coerce.number().optional().nullable().describe('Number of parameters in the backtest.'),
            psr: zod.coerce.number().optional().nullable().describe('Price-to-sales ratio.'),
            securityTypes: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('The number of security types (QuantConnect.SecurityType) present in the backtest.'),
            sortinoRatio: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Sortino ratio with respect to risk free rate; measures excess of return per unit of downside risk.'),
            trades: zod.coerce.number().optional().nullable().describe('Number of trades in the backtest.'),
            treynorRatio: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe(
                'Treynor ratio statistic is a measurement of the returns earned in excess of that which could have been earned on an investment that has no diversifiable risk.'
              ),
            winRate: zod.coerce.number().optional().nullable().describe('The ratio of the number of winning trades to the total number of trades.'),
          })
          .describe('Result object class for the List Backtest response from the API.')
      )
      .optional()
      .nullable()
      .describe('Collection of backtest summaries for a project.'),
    count: zod.coerce.number().optional().nullable().describe('Number of backtest summaries retrieved in the response.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Collection container for a list of backtest summaries for a project.')

/**
 * @summary Read out the orders of a backtest.
 */
export const readBacktestOrderBody = zod
  .object({
    start: zod.number().describe('Starting index of the orders to be fetched.'),
    end: zod.number().describe('Last index of the orders to be fetched. Note that end - start must be less than 100.'),
    projectId: zod.number().describe('Id of the project from which to read the backtest.'),
    backtestId: zod.string().describe('Id of the backtest from which to read the orders.'),
  })
  .describe('Request to read orders from a backtest.')

export const readBacktestOrderResponse = zod
  .object({
    orders: zod
      .array(
        zod
          .object({
            id: zod.coerce.number().optional().nullable().describe('Order ID.'),
            contingentId: zod.coerce.number().optional().nullable().describe('Order Id to process before processing this order.'),
            brokerId: zod
              .array(zod.string())
              .optional()
              .nullable()
              .describe('Brokerage Id for this order for when the brokerage splits orders into multiple pieces.'),
            symbol: zod
              .object({
                value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
              })
              .optional()
              .nullable()
              .describe(
                'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
              ),
            limitPrice: zod.coerce.number().optional().nullable().describe('Limit price of the Order.'),
            stopPrice: zod.coerce.number().optional().nullable().describe('Stop price of the Order.'),
            stopTriggered: zod.boolean().optional().nullable().describe('Indicates if the stop price has been reached, so the limit order has been triggered.'),
            price: zod.coerce.number().optional().nullable().describe('Price of the Order.'),
            priceCurrency: zod.string().optional().nullable().describe('Currency for the order price.'),
            time: zod.coerce.date().optional().nullable().describe('Gets the UTC time the order was created.'),
            createdTime: zod.coerce.date().optional().nullable().describe('Gets the UTC time this order was created. Alias for Time.'),
            lastFillTime: zod.coerce
              .date()
              .optional()
              .nullable()
              .describe('Gets the UTC time the last fill was received, or null if no fills have been received.'),
            lastUpdateTime: zod.coerce
              .date()
              .optional()
              .nullable()
              .describe('Gets the UTC time this order was last updated, or null if the order has not been updated.'),
            canceledTime: zod.coerce.date().optional().nullable().describe('Gets the UTC time this order was canceled, or null if the order was not canceled.'),
            quantity: zod.coerce.number().optional().nullable().describe('Number of shares to execute.'),
            type: zod
              .union([
                zod.literal(0),
                zod.literal(1),
                zod.literal(2),
                zod.literal(3),
                zod.literal(4),
                zod.literal(5),
                zod.literal(6),
                zod.literal(7),
                zod.literal(8),
                zod.literal(9),
                zod.literal(10),
                zod.literal(11),
              ])
              .optional()
              .nullable()
              .describe(
                'Order type. 0=Market, 1=Limit, 2=StopMarket, 3=StopLimit, 4=MarketOnOpen, 5=MarketOnClose, 6=OptionExercise, 7=LimitIfTouched, 8=ComboMarket, 9=ComboLimit, 10=ComboLegLimit, 11=TrailingStop.'
              ),
            status: zod
              .union([
                zod.literal(0),
                zod.literal(1),
                zod.literal(2),
                zod.literal(3),
                zod.literal(5),
                zod.literal(6),
                zod.literal(7),
                zod.literal(8),
                zod.literal(9),
              ])
              .optional()
              .nullable()
              .describe(
                'Status of the Order. 0=New, 1=Submitted, 2=PartiallyFilled, 3=Filled, 5=Canceled, 6=None, 7=Invalid, 8=CancelPending, 9=UpdateSubmitted.'
              ),
            tag: zod.string().optional().nullable().describe('Tag the order with some custom data.'),
            securityType: zod
              .union([
                zod.literal(0),
                zod.literal(1),
                zod.literal(2),
                zod.literal(3),
                zod.literal(4),
                zod.literal(5),
                zod.literal(6),
                zod.literal(7),
                zod.literal(8),
                zod.literal(9),
                zod.literal(10),
                zod.literal(11),
              ])
              .optional()
              .nullable()
              .describe(
                'Type of tradable security / underlying asset. 0=Base, 1=Equity, 2=Option, 3=Commodity, 4=Forex, 5=Future, 6=Cfd, 7=Crypto, 8=FutureOption, 9=Index, 10=IndexOption, 11=CryptoFuture.'
              ),
            direction: zod
              .union([zod.literal(0), zod.literal(1), zod.literal(2)])
              .optional()
              .nullable()
              .describe('Order Direction Property based off Quantity. 0=Buy, 1=Sell, 2=Hold.'),
            value: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the executed value of this order. If the order has not yet filled, then this will return zero.'),
            orderSubmissionData: zod
              .object({
                bidPrice: zod.coerce.number().optional().nullable().describe('The bid price at order submission time.'),
                askPrice: zod.coerce.number().optional().nullable().describe('The ask price at order submission time.'),
                lastPrice: zod.coerce.number().optional().nullable().describe('The current price at order submission time.'),
              })
              .optional()
              .nullable()
              .describe('Stores time and price information available at the time an order was submitted.'),
            isMarketable: zod.boolean().optional().nullable().describe('Returns true if the order is a marketable order.'),
            properties: zod
              .object({
                timeInForce: zod
                  .object({})
                  .optional()
                  .nullable()
                  .describe('Defines the length of time over which an order will continue working before it is cancelled.'),
              })
              .optional()
              .nullable()
              .describe('Additional properties of the order'),
            events: zod
              .array(
                zod
                  .object({
                    algorithmId: zod.string().optional().nullable().describe('Algorithm Id, BacktestId or DeployId.'),
                    symbol: zod.string().optional().nullable().describe('Easy access to the order symbol associated with this event.'),
                    symbolValue: zod
                      .string()
                      .optional()
                      .nullable()
                      .describe('The current symbol for this ticker; It is a user friendly symbol representation.'),
                    symbolPermtick: zod.string().optional().nullable().describe('The original symbol used to generate this symbol.'),
                    orderId: zod.coerce.number().optional().nullable().describe('Id of the order this event comes from.'),
                    orderEventId: zod.coerce.number().optional().nullable().describe('The unique order event id for each order.'),
                    id: zod.string().optional().nullable().describe('The unique order event Id for each order.'),
                    status: zod
                      .enum(['new', 'submitted', 'partiallyFilled', 'filled', 'canceled', 'none', 'invalid', 'cancelPending', 'updateSubmitted'])
                      .optional()
                      .nullable()
                      .describe('Status of the Order.'),
                    orderFeeAmount: zod.coerce.number().optional().nullable().describe('The fee amount associated with the order.'),
                    orderFeeCurrency: zod.string().optional().nullable().describe('The fee currency associated with the order.'),
                    fillPrice: zod.coerce.number().optional().nullable().describe('Fill price information about the order.'),
                    fillPriceCurrency: zod.string().optional().nullable().describe('Currency for the fill price.'),
                    fillQuantity: zod.coerce.number().optional().nullable().describe('Number of shares of the order that was filled in this event.'),
                    direction: zod.enum(['buy', 'sell', 'hold']).optional().nullable().describe('Direction of the order.'),
                    message: zod.string().optional().nullable().describe('Any message from the exchange.'),
                    isAssignment: zod.boolean().optional().nullable().describe('True if the order event is an assignment.'),
                    stopPrice: zod.coerce.number().optional().nullable().describe('The current stop price.'),
                    limitPrice: zod.coerce.number().optional().nullable().describe('The current limit price.'),
                    quantity: zod.coerce.number().optional().nullable().describe('The current order quantity.'),
                    time: zod.coerce.number().optional().nullable().describe('The time of this event in unix timestamp.'),
                    isInTheMoney: zod.boolean().optional().nullable().describe("True if the order event's option is In-The-Money (ITM)."),
                  })
                  .describe('Change in an order state applied to user algorithm portfolio')
              )
              .optional()
              .nullable()
              .describe('The order events.'),
            trailingAmount: zod.coerce.number().optional().nullable().describe('Trailing amount for a trailing stop order.'),
            trailingPercentage: zod
              .boolean()
              .optional()
              .nullable()
              .describe('Determines whether the trailingAmount is a percentage or an absolute currency value.'),
            groupOrderManager: zod
              .object({
                id: zod.coerce.number().optional().nullable().describe('The unique order group Id.'),
                quantity: zod.coerce.number().optional().nullable().describe('The group order quantity.'),
                count: zod.coerce.number().optional().nullable().describe('The total order count associated with this order group.'),
                limitPrice: zod.coerce.number().optional().nullable().describe('The limit price associated with this order group if any.'),
                orderIds: zod.array(zod.coerce.number()).optional().nullable().describe('The order Ids in this group.'),
                direction: zod.coerce.number().optional().nullable().describe('Order Direction Property based off Quantity.'),
              })
              .optional()
              .nullable()
              .describe('Manager of a group of orders.'),
            triggerPrice: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('The price which, when touched, will trigger the setting of a limit order at limitPrice.'),
            triggerTouched: zod.boolean().optional().nullable().describe('Whether or not the triggerPrice has been touched.'),
          })
          .describe('Order struct for placing new trade.')
      )
      .optional()
      .nullable(),
    length: zod.coerce.number().optional().nullable().describe('Total number of returned orders'),
  })
  .describe('Contains orders and the number of orders of the backtest in the request criteria.')

/**
 * @summary Read out the report of a backtest.
 */
export const readBacktestsReportBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to read.'),
    backtestId: zod.string().describe('Id of the backtest to read.'),
  })
  .describe('Request to read out the report of a backtest.')

export const readBacktestsReportResponse = zod.union([
  zod
    .object({
      report: zod.string().optional().nullable().describe('HTML data of the report with embedded base64 images.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Backtest Report Response wrapper.'),
  zod
    .object({
      generating: zod.boolean().optional().nullable().describe('Indicate if the report is generating.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Backtest Report Response wrapper.'),
])

/**
 * @summary Read a chart from a backtest.
 */
export const readBacktestChartBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the backtest.'),
    backtestId: zod.string().describe('Id of the backtest for this chart request.'),
    name: zod.string().describe('The requested chart name.'),
    count: zod.number().describe('The number of data points to request.'),
    start: zod.number().describe('The start timestamp of the request in Unix time.'),
    end: zod.number().describe('The end timestamp of the request in Unix time.'),
  })
  .describe('Request body to obtain a chart from a backtest.')

export const readBacktestChartResponse = zod.union([
  zod
    .object({
      progress: zod.coerce.number().optional().nullable().describe('Loading percentage of the data generation process.'),
      status: zod.enum(['loading']).optional().nullable().describe('Status of the data generation process.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    })
    .describe('Response when the requested chart or orders are being generated.'),
  zod
    .object({
      chart: zod
        .object({
          name: zod.string().optional().nullable().describe('Name of the Chart.'),
          chartType: zod
            .union([zod.literal(0), zod.literal(1)])
            .optional()
            .nullable()
            .describe('Type of the Chart. 0=Overlayed, 1=Stacked.'),
          series: zod
            .record(
              zod.string(),
              zod
                .object({
                  name: zod.string().optional().nullable().describe('Name of the series.'),
                  unit: zod.string().optional().nullable().describe('Axis for the chart series.'),
                  index: zod.coerce.number().optional().nullable().describe('Index/position of the series on the chart.'),
                  values: zod
                    .union([zod.array(zod.array(zod.union([zod.coerce.number().nullable(), zod.string()]))), zod.array(zod.record(zod.string(), zod.any()))])
                    .optional()
                    .nullable()
                    .describe('Values for the series plot. These values are assumed to be in ascending time order (first points earliest, last points latest)'),
                  seriesType: zod
                    .union([
                      zod.literal(0),
                      zod.literal(1),
                      zod.literal(2),
                      zod.literal(3),
                      zod.literal(4),
                      zod.literal(5),
                      zod.literal(6),
                      zod.literal(7),
                      zod.literal(9),
                      zod.literal(19),
                    ])
                    .optional()
                    .nullable()
                    .describe(
                      'Chart type for the series. 0=Line, 1=Scatter, 2=Candle, 3=Bar, 4=Flag, 5=StackedArea, 6=Pie, 7=Treemap, 9=Heatmap, 10=Scatter3d.'
                    ),
                  color: zod.string().optional().nullable().describe('Color of the series.'),
                  scatterMarkerSymbol: zod
                    .enum(['none', 'circle', 'square', 'diamond', 'triangle', 'triangle-down'])
                    .optional()
                    .nullable()
                    .describe('Shape or symbol for the marker in a scatter plot.'),
                })
                .describe('Chart Series Object - Series data and properties for a chart.')
            )
            .optional()
            .nullable()
            .describe('Series Objects for this Chart.'),
        })
        .optional()
        .nullable()
        .describe('Single Parent Chart Object for Custom Charting.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Response with the requested chart from a live algorithm or backtest'),
])

/**
 * @summary Read out the insights of a backtest.
 */
export const readBacktestsInsightsBody = zod
  .object({
    start: zod.number().describe('Starting index of the insights to be fetched.'),
    end: zod.number().describe('Last index of the insights to be fetched. Note that end - start must be less than 100.'),
    projectId: zod.number().describe('Id of the project from which to read the backtest.'),
    backtestId: zod.string().describe('Id of the backtest from which to read the insights.'),
  })
  .describe('Request to read insights from a backtest.')

export const readBacktestsInsightsResponse = zod
  .object({
    insights: zod
      .array(
        zod
          .object({
            id: zod.string().optional().nullable().describe('Id of the insight.'),
            groupId: zod.string().optional().nullable().describe('Id of the group of insights.'),
            sourceModel: zod.string().optional().nullable().describe('An identifier for the source model that generated this insight.'),
            generatedTime: zod.coerce.number().optional().nullable().describe('Gets the Unix time this insight was generated.'),
            closeTime: zod.coerce.number().optional().nullable().describe('Gets the Unix time this insight was closed.'),
            symbol: zod.string().optional().nullable().describe('Gets the symbol Id this insight is for.'),
            ticker: zod.string().optional().nullable().describe('Gets the symbol ticker this insight is for.'),
            type: zod.enum(['price', 'volatility']).optional().nullable().describe('Gets the type of insight.'),
            reference: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the initial reference value this insight is predicting against. That is, the price of the asset when the insight was created.'),
            referenceFinal: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the final reference value, used for scoring, this insight is predicting against.'),
            direction: zod.enum(['down', 'flat', 'up']).optional().nullable().describe('Gets the predicted direction.'),
            period: zod.coerce.number().optional().nullable().describe('Gets the period, in seconds, over which this insight is expected to come to fruition.'),
            magnitude: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the predicted percent change in the insight type (price/volatility). This value can be null.'),
            confidence: zod.coerce.number().optional().nullable().describe('Gets the confidence in this insight. This value can be null.'),
            weight: zod.coerce.number().optional().nullable().describe('Gets the portfolio weight of this insight. This value can be null.'),
            scoreFinal: zod.boolean().optional().nullable().describe("Gets whether or not this is the insight's final score."),
            scoreDirection: zod.coerce.number().optional().nullable().describe('Gets the direction score.'),
            scoreMagnitude: zod.coerce.number().optional().nullable().describe('Gets the magnitude score.'),
            estimatedValue: zod.coerce.number().optional().nullable().describe('Gets the estimated value of this insight in the account currency.'),
            tag: zod.string().optional().nullable().describe("The insight's tag containing additional information."),
          })
          .describe('Insight struct for emitting new prediction.')
      )
      .optional()
      .nullable()
      .describe('Collection of insights.'),
    length: zod.coerce.number().optional().nullable().describe('Total number of returned insights.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Contains insights and the number of insights of the backtest in the request criteria.')

/**
 * @summary Update the name or note of a backtest.
 */
export const updateBacktestBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the backtest.'),
    backtestId: zod.string().describe('Id of the backtest to update.'),
    name: zod.string().optional().nullable().describe('Name to assign to the backtest.'),
    note: zod.string().optional().nullable().describe('Note to attach to the backtest.'),
  })
  .describe("Request to update a backtest's name or note.")

export const updateBacktestResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Delete a backtest from a project.
 */
export const deleteBacktestBody = zod
  .object({
    projectId: zod.number().describe('Id of the project that contains the backtest.'),
    backtestId: zod.string().describe('Id of the backtest to delete.'),
  })
  .describe('Request to delete a backtest.')

export const deleteBacktestResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Returns a list of lean versions with basic information for each version.
 */
export const readLeanVersionResponse = zod
  .object({
    versions: zod
      .array(
        zod.object({
          id: zod.coerce.number().optional().nullable().describe('Id of the LEAN version.'),
          created: zod.coerce.date().optional().nullable().describe('Date when this version was created.'),
          description: zod.string().optional().nullable().describe('Description of the LEAN version.'),
          leanHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN repository.'),
          leanCloudHash: zod.string().optional().nullable().describe('Commit Hash in the LEAN Cloud repository.'),
          name: zod.string().optional().nullable().describe('Name of the branch where the commit is.'),
          ref: zod.string().optional().nullable().describe('Reference to the branch where the commit is.'),
          public: zod.boolean().optional().nullable().describe('Indicates if the version is available for the public.'),
        })
      )
      .optional()
      .nullable()
      .describe('List of LEAN versions with their basic descriptions.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Contains the LEAN versions with their basic descriptions.')

/**
 * @summary Read a chart from a live algorithm.
 */
export const readLiveChartBody = zod
  .object({
    projectId: zod.number().describe("Id of the project that's live trading."),
    name: zod.string().describe('Name of the chart to read.'),
    count: zod.number().describe('The number of data points to request.'),
    start: zod.number().describe('The unix start time of the request.'),
    end: zod.number().describe('The unix end time of the request.'),
  })
  .describe('Request to body to obtain a chart from a live algorithm.')

export const readLiveChartResponse = zod.union([
  zod
    .object({
      progress: zod.coerce.number().optional().nullable().describe('Loading percentage of the data generation process.'),
      status: zod.enum(['loading']).optional().nullable().describe('Status of the data generation process.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    })
    .describe('Response when the requested chart or orders are being generated.'),
  zod
    .object({
      chart: zod
        .object({
          name: zod.string().optional().nullable().describe('Name of the Chart.'),
          chartType: zod
            .union([zod.literal(0), zod.literal(1)])
            .optional()
            .nullable()
            .describe('Type of the Chart. 0=Overlayed, 1=Stacked.'),
          series: zod
            .record(
              zod.string(),
              zod
                .object({
                  name: zod.string().optional().nullable().describe('Name of the series.'),
                  unit: zod.string().optional().nullable().describe('Axis for the chart series.'),
                  index: zod.coerce.number().optional().nullable().describe('Index/position of the series on the chart.'),
                  values: zod
                    .union([zod.array(zod.array(zod.union([zod.coerce.number().nullable(), zod.string()]))), zod.array(zod.record(zod.string(), zod.any()))])
                    .optional()
                    .nullable()
                    .describe('Values for the series plot. These values are assumed to be in ascending time order (first points earliest, last points latest)'),
                  seriesType: zod
                    .union([
                      zod.literal(0),
                      zod.literal(1),
                      zod.literal(2),
                      zod.literal(3),
                      zod.literal(4),
                      zod.literal(5),
                      zod.literal(6),
                      zod.literal(7),
                      zod.literal(9),
                      zod.literal(19),
                    ])
                    .optional()
                    .nullable()
                    .describe(
                      'Chart type for the series. 0=Line, 1=Scatter, 2=Candle, 3=Bar, 4=Flag, 5=StackedArea, 6=Pie, 7=Treemap, 9=Heatmap, 10=Scatter3d.'
                    ),
                  color: zod.string().optional().nullable().describe('Color of the series.'),
                  scatterMarkerSymbol: zod
                    .enum(['none', 'circle', 'square', 'diamond', 'triangle', 'triangle-down'])
                    .optional()
                    .nullable()
                    .describe('Shape or symbol for the marker in a scatter plot.'),
                })
                .describe('Chart Series Object - Series data and properties for a chart.')
            )
            .optional()
            .nullable()
            .describe('Series Objects for this Chart.'),
        })
        .optional()
        .nullable()
        .describe('Single Parent Chart Object for Custom Charting.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Response with the requested chart from a live algorithm or backtest'),
])

/**
 * @summary Authorize an external connection with a live brokerage or data provider.
 */
export const authorizeLiveAuth0Body = zod
  .object({
    brokerage: zod.enum(['alpaca', 'tradestation', 'charlesschwab', 'tastytrade']).describe('The brokerage to authenticate a connection with.'),
  })
  .describe('Request for authenticating with an external brokerage or data provider for a live algorithm.')

/**
 * @summary Read an authentication token for a brokerage or data provider.
 */
export const readLiveAuth0Body = zod
  .object({
    brokerage: zod.enum(['alpaca', 'tradestation', 'charlesschwab', 'tastytrade']).describe('The brokerage to authenticate a connection with.'),
  })
  .describe('Request for authenticating with an external brokerage or data provider for a live algorithm.')

export const readLiveAuth0Response = zod
  .object({
    authorization: zod
      .object({})
      .optional()
      .nullable()
      .describe('Authentication information from the data provider or brokerage, including the access token or refresh token.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response for authenticating with an external brokerage or data provider for a live algorithm.')

/**
 * @summary Create a live algorithm.
 */
export const createLiveBodyDataProvidersQuantConnectBrokerageIdDefault = 'QuantConnectBrokerage'

export const createLiveBody = zod.object({
  versionId: zod
    .string()
    .describe(
      'The version of the Lean used to run the algorithm. -1 is master, however, sometimes this can create problems with live deployments. If you experience problems using, try specifying the version of Lean you would like to use.'
    ),
  projectId: zod.number().describe('Project Id.'),
  compileId: zod.string().describe('Compile Id.'),
  nodeId: zod.string().describe('Id of the node that will run the algorithm.'),
  brokerage: zod
    .union([
      zod
        .object({
          id: zod.enum(['QuantConnectBrokerage']).describe('Id of the module.'),
          holdings: zod
            .array(
              zod
                .object({
                  symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                  symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                  quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                  averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                })
                .describe('Holding object class for creating a live algorithm.')
            )
            .optional()
            .nullable()
            .describe('List of holdings for the brokerage.'),
          cash: zod
            .array(
              zod
                .object({
                  amount: zod.number().optional().nullable().describe('The amount of cash.'),
                  currency: zod.string().optional().nullable().describe('The currency in which the cash amount is denominated.'),
                })
                .describe('Represents a cash amount which can be converted to account currency using a currency converter.')
            )
            .optional()
            .nullable()
            .describe('List of cash amount.'),
        })
        .describe('Settings for using Paper Trading as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['InteractiveBrokersBrokerage']).describe('Id of the module.'),
          'ib-user-name': zod.string().describe('Your Interactive Brokers username.'),
          'ib-account': zod.string().describe('Your Interactive Brokers account id.'),
          'ib-password': zod.string().describe('Your Interactive Brokers password.'),
          'ib-weekly-restart-utc-time': zod
            .string()
            .describe(
              'Weekly restart UTC time (hh:mm:ss). Each week on Sunday your algorithm restarts at this time and requires 2FA verification. This is required by Interactive Brokers.'
            ),
          'ib-financial-advisors-group-filter': zod
            .string()
            .optional()
            .nullable()
            .describe(
              'Use this field to filter data by a specific financial advisor group within your Interactive Brokers account. Leave blank to include all groups.'
            ),
        })
        .describe('Settings for using Interactive Brokers as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['TradierBrokerage']).describe('Id of the module.'),
          'tradier-account-id': zod.string().describe('Your Tradier account id.'),
          'tradier-access-token': zod.string().describe('Your Tradier access token.'),
          'tradier-environment': zod.enum(['live', 'paper']).describe('Whether the developer sandbox should be used.'),
        })
        .describe('Settings for using Tradier as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BitfinexBrokerage']).describe('Id of the module.'),
          'bitfinex-api-key': zod.string().describe('Your Bitfinex API key.'),
          'bitfinex-api-secret': zod.string().describe('Your Bitfinex API secret.'),
        })
        .describe('Settings for using Bitfinex as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['CoinbaseBrokerage']).describe('Id of the module.'),
          'coinbase-api-name': zod.string().describe('Your Coinbase Advanced Trade API name.'),
          'coinbase-api-private-key': zod.string().describe('Your Coinbase Advanced Trade API private key.'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Coinbase Advanced Trade as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
          'binance-exchange-name': zod.enum(['Binance']).describe('Binance exchange name.'),
          'binance-api-key': zod.string().describe('Your Binance API key'),
          'binance-api-secret': zod.string().describe('Your Binance API secret'),
          'binance-use-testnet': zod.enum(['live', 'paper']).describe('Whether the testnet should be used'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Binance as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
          'binance-exchange-name': zod.enum(['BinanceUS']).describe('Binance exchange name.'),
          'binanceus-api-key': zod.string().describe('Your Binance API key'),
          'binanceus-api-secret': zod.string().describe('Your Binance API secret'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Binance as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
          'binance-exchange-name': zod.enum(['Binance-USDM-Futures']).describe('Binance exchange name.'),
          'binance-api-key': zod.string().describe('Your Binance API key'),
          'binance-api-secret': zod.string().describe('Your Binance API secret'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Binance as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
          'binance-exchange-name': zod.enum(['Binance-COIN-Futures']).describe('Binance exchange name.'),
          'binance-api-key': zod.string().describe('Your Binance API key'),
          'binance-api-secret': zod.string().describe('Your Binance API secret'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Binance as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['TradingTechnologiesBrokerage']).describe('Id of the module.'),
          'tt-user-name': zod.string().describe('Your Trading Technologies username'),
          'tt-session-password': zod.string().describe('Your Trading Technologies session password'),
          'tt-account-name': zod.string().describe('Your Trading Technologies account name'),
          'tt-rest-app-key': zod.string().describe('Your Trading Technologies REST app key'),
          'tt-rest-app-secret': zod.string().describe('Your Trading Technologies REST app secret'),
          'tt-rest-environment': zod.enum(['live', 'uat']).describe('The REST environment to run in'),
          'tt-order-routing-sender-comp-id': zod.string().describe('The order routing sender comp id to use'),
          cash: zod
            .array(
              zod
                .object({
                  amount: zod.number().optional().nullable().describe('The amount of cash.'),
                  currency: zod.string().optional().nullable().describe('The currency in which the cash amount is denominated.'),
                })
                .describe('Represents a cash amount which can be converted to account currency using a currency converter.')
            )
            .describe('List of cash amount.'),
        })
        .describe('Settings for using Trading Technologies as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['KrakenBrokerage']).describe('Id of the module.'),
          'kraken-api-key': zod.string().describe('Your Kraken API key.'),
          'kraken-api-secret': zod.string().describe('Your Kraken API secret.'),
          'kraken-verification-tier': zod.enum(['Starter', 'Intermediate', 'Pro']).describe('Your Kraken Verification Tier.'),
        })
        .describe('Settings for using Kraken as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['BybitBrokerage']).describe('Id of the module.'),
          'bybit-api-key': zod.string().describe('Your Bybit API key'),
          'bybit-api-secret': zod.string().describe('Your Bybit API secret'),
          'bybit-vip-level': zod
            .enum(['VIP0', 'VIP1', 'VIP2', 'VIP3', 'VIP4', 'VIP5', 'SupremeVIP', 'Pro1', 'Pro2', 'Pro3', 'Pro4', 'Pro5'])
            .describe('Your Bybit VIP Level'),
        })
        .and(
          zod.object({
            holdings: zod
              .array(
                zod
                  .object({
                    symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                    symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                    quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                    averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                  })
                  .describe('Holding object class for creating a live algorithm.')
              )
              .optional()
              .nullable()
              .describe('List of holdings for the brokerage.'),
          })
        )
        .describe('Settings for using Bybit as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['OandaBrokerage']).describe('Id of the module.'),
          'oanda-account-id': zod
            .string()
            .describe(
              "Your OANDA account id can be found on your OANDA Account Statement page (https://www.oanda.com/account/statement/). It follows the following format '###-###-######-###'."
            ),
          'oanda-access-token': zod
            .string()
            .describe(
              'Your OANDA API token. You can generate an API token from the Manage API Access page (https://www.oanda.com/account/tpa/personal_token).'
            ),
          'oanda-environment': zod.enum(['Practice', 'Trade']).describe('The environment to run in. Practice for fxTrade Practice, Trade for fxTrade.'),
        })
        .describe('Settings for using Oanda as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['WolverineBrokerage']).describe('Id of the module.'),
          'wolverine-on-behalf-of-comp-id': zod.string().describe('Value used to identify the trading firm.'),
          'wolverine-account': zod.string().describe('Wolverine Execution Services account name.'),
          cash: zod
            .array(
              zod
                .object({
                  amount: zod.number().optional().nullable().describe('The amount of cash.'),
                  currency: zod.string().optional().nullable().describe('The currency in which the cash amount is denominated.'),
                })
                .describe('Represents a cash amount which can be converted to account currency using a currency converter.')
            )
            .optional()
            .nullable()
            .describe('List of cash amount.'),
          holdings: zod
            .array(
              zod
                .object({
                  symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                  symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                  quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                  averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                })
                .describe('Holding object class for creating a live algorithm.')
            )
            .optional()
            .nullable()
            .describe('List of holdings for the brokerage.'),
        })
        .describe('Settings for using Wolverine Execution Services as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['CharlesSchwabBrokerage']).describe('Id of the module.'),
          'charles-schwab-account-number': zod.string().describe('Your Charles Schwab account number.'),
        })
        .describe('Settings for using Charles Schwab as a data provider or the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['RBIBrokerage']).describe('Id of the module.'),
          'rbi-on-behalf-of-comp-id': zod.string().describe('Value used to identify the trading firm.'),
          'rbi-account': zod.string().describe('RBI account name.'),
          cash: zod
            .array(
              zod
                .object({
                  amount: zod.number().optional().nullable().describe('The amount of cash.'),
                  currency: zod.string().optional().nullable().describe('The currency in which the cash amount is denominated.'),
                })
                .describe('Represents a cash amount which can be converted to account currency using a currency converter.')
            )
            .optional()
            .nullable()
            .describe('List of cash amount.'),
          holdings: zod
            .array(
              zod
                .object({
                  symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                  symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                  quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                  averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                })
                .describe('Holding object class for creating a live algorithm.')
            )
            .optional()
            .nullable()
            .describe('List of holdings for the brokerage.'),
        })
        .describe('Settings for using RBI as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['TerminalLinkBrokerage']).describe('Id of the module.'),
          'terminal-link-connection-type': zod.enum(['SAPI']).describe('Terminal Link Connection Type.'),
          'terminal-link-server-auth-id': zod
            .string()
            .describe(
              "Your unique user identifier (UUID). The UUID is a unique integer identifier that's assigned to each Bloomberg Anywhere user. If you don't know your UUID, contact Bloomberg."
            ),
          'terminal-link-environment': zod.enum(['Production', 'Beta']).describe('The environment to run in.'),
          'terminal-link-server-host': zod.string().describe('The public IP address of the SAPI AWS server.'),
          'terminal-link-server-port': zod.number().describe('The port where SAPI is listening. The default port is 8194.'),
          'terminal-link-emsx-broker': zod.string().describe('The EMSX broker to use.'),
          'terminal-link-emsx-account': zod.string().describe('The account to which LEAN should route orders.'),
          'terminal-link-openfigi-api-key': zod.string().describe('The OpenFIGI API key to use for mapping options.'),
          'terminal-link-emsx-team': zod.string().optional().nullable().describe('The EMSX team to use.'),
          cash: zod
            .array(
              zod
                .object({
                  amount: zod.number().optional().nullable().describe('The amount of cash.'),
                  currency: zod.string().optional().nullable().describe('The currency in which the cash amount is denominated.'),
                })
                .describe('Represents a cash amount which can be converted to account currency using a currency converter.')
            )
            .optional()
            .nullable()
            .describe('List of cash amount.'),
          holdings: zod
            .array(
              zod
                .object({
                  symbolId: zod.string().optional().nullable().describe('Symbol Id of the holding.'),
                  symbol: zod.string().optional().nullable().describe('Symbol ticker of the holding.'),
                  quantity: zod.number().optional().nullable().describe('Quantity of the Symbol you hold.'),
                  averagePrice: zod.number().optional().nullable().describe('Average price of your Holding in the currency the symbol is traded in.'),
                })
                .describe('Holding object class for creating a live algorithm.')
            )
            .optional()
            .nullable()
            .describe('List of holdings for the brokerage.'),
        })
        .describe('Settings for using TerminalLink as the brokerage for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['TradeStationBrokerage']).describe('Id of the module.'),
          'trade-station-client-id': zod.string().describe('Your TradeStation client Id.'),
          'trade-station-account-id': zod.string().describe('The TradeStation account Id.'),
          'trade-station-refresh-token': zod.string().describe('The TradeStation refresh token.'),
          'trade-station-environment': zod.enum(['live', 'paper']).describe('The environment to run the algorithm in.'),
        })
        .describe('Settings for using TradeStation as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['TastytradeBrokerage']).describe('Id of the module.'),
          'tastytrade-account-number': zod.number().describe('Your Tastytrade account number.'),
          'tastytrade-refresh-token': zod.string().describe('The TradeStation refresh token.'),
        })
        .describe('Settings for using Tastytrade as the brokerage or a data provider for a live algorithm.'),
      zod
        .object({
          id: zod.enum(['AlpacaBrokerage']).describe('Id of the module.'),
          'alpaca-access-token': zod.string().describe('Your Alpaca access token for authentication.'),
          'alpaca-environment': zod.enum(['live', 'paper']).describe('The environment to run the algorithm in.'),
        })
        .describe('Settings for using Alpaca as the brokerage for a live algorithm.'),
    ])
    .describe('Brokerage configuration for the live algorithm.'),
  dataProviders: zod
    .object({
      QuantConnectBrokerage: zod
        .object({
          id: zod.enum(['QuantConnectBrokerage']).describe('Id of the module.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using QuantConnect as a data provider for a live algorithm.'),
      InteractiveBrokersBrokerage: zod
        .object({
          id: zod.enum(['InteractiveBrokersBrokerage']).describe('Id of the module.'),
          'ib-user-name': zod.string().describe('Your Interactive Brokers username.'),
          'ib-account': zod.string().describe('Your Interactive Brokers account id.'),
          'ib-password': zod.string().describe('Your Interactive Brokers password.'),
          'ib-weekly-restart-utc-time': zod
            .string()
            .describe(
              'Weekly restart UTC time (hh:mm:ss). Each week on Sunday your algorithm restarts at this time and requires 2FA verification. This is required by Interactive Brokers.'
            ),
          'ib-financial-advisors-group-filter': zod
            .string()
            .optional()
            .nullable()
            .describe(
              'Use this field to filter data by a specific financial advisor group within your Interactive Brokers account. Leave blank to include all groups.'
            ),
        })
        .describe('Settings for using Interactive Brokers as the brokerage or a data provider for a live algorithm.')
        .optional()
        .nullable()
        .describe('Settings for using Interactive Brokers as a data provider for a live algorithm.'),
      TradierBrokerage: zod
        .object({
          id: zod.enum(['TradierBrokerage']).describe('Id of the module.'),
          'tradier-account-id': zod.string().describe('Your Tradier account id.'),
          'tradier-access-token': zod.string().describe('Your Tradier access token.'),
          'tradier-environment': zod.enum(['live', 'paper']).describe('Whether the developer sandbox should be used.'),
        })
        .describe('Settings for using Tradier as the brokerage for a live algorithm.')
        .optional()
        .nullable()
        .describe('Settings for using Tradier as a data provider for a live algorithm.'),
      BitfinexBrokerage: zod
        .object({
          id: zod.enum(['BitfinexBrokerage']).describe('Id of the module.'),
          'bitfinex-api-key': zod.string().describe('Your Bitfinex API key.'),
          'bitfinex-api-secret': zod.string().describe('Your Bitfinex API secret.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Bitfinex as the brokerage or a data provider for a live algorithm.'),
      CoinbaseBrokerage: zod
        .object({
          id: zod.enum(['CoinbaseBrokerage']).describe('Id of the module.'),
          'coinbase-api-name': zod.string().describe('Your Coinbase Advanced Trade API name.'),
          'coinbase-api-private-key': zod.string().describe('Your Coinbase Advanced Trade API private key.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Coinbase Advanced Trade as a data provider for a live algorithm.'),
      BinanceBrokerage: zod
        .union([
          zod
            .object({
              id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
              'binance-exchange-name': zod.enum(['Binance']).describe('Binance exchange name.'),
              'binance-api-key': zod.string().describe('Your Binance API key'),
              'binance-api-secret': zod.string().describe('Your Binance API secret'),
              'binance-use-testnet': zod.enum(['live', 'paper']).describe('Whether the testnet should be used'),
            })
            .describe('Settings for using Binance as a data provider for a live algorithm.'),
          zod
            .object({
              id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
              'binance-exchange-name': zod.enum(['BinanceUS']).describe('Binance exchange name.'),
              'binanceus-api-key': zod.string().describe('Your Binance API key'),
              'binanceus-api-secret': zod.string().describe('Your Binance API secret'),
            })
            .describe('Settings for using Binance as a data provider for a live algorithm.'),
          zod
            .object({
              id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
              'binance-exchange-name': zod.enum(['Binance-USDM-Futures']).describe('Binance exchange name.'),
              'binance-api-key': zod.string().describe('Your Binance API key'),
              'binance-api-secret': zod.string().describe('Your Binance API secret'),
            })
            .describe('Settings for using Binance as a data provider for a live algorithm.'),
          zod
            .object({
              id: zod.enum(['BinanceBrokerage']).describe('Id of the module.'),
              'binance-exchange-name': zod.enum(['Binance-COIN-Futures']).describe('Binance exchange name.'),
              'binance-api-key': zod.string().describe('Your Binance API key'),
              'binance-api-secret': zod.string().describe('Your Binance API secret'),
            })
            .describe('Settings for using Binance as a data provider for a live algorithm.'),
        ])
        .optional()
        .nullable(),
      KrakenBrokerage: zod
        .object({
          id: zod.enum(['KrakenBrokerage']).describe('Id of the module.'),
          'kraken-api-key': zod.string().describe('Your Kraken API key.'),
          'kraken-api-secret': zod.string().describe('Your Kraken API secret.'),
          'kraken-verification-tier': zod.enum(['Starter', 'Intermediate', 'Pro']).describe('Your Kraken Verification Tier.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Kraken as the brokerage or a data provider for a live algorithm.'),
      PolygonDataFeed: zod
        .object({
          id: zod.enum(['Polygon']).describe('Id of the module.'),
          'polygon-api-key': zod.string().describe('Your Polygon.io API Key.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Polygon as a data provider for a live algorithm.'),
      BybitBrokerage: zod
        .object({
          id: zod.enum(['BybitBrokerage']).describe('Id of the module.'),
          'bybit-api-key': zod.string().describe('Your Bybit API key'),
          'bybit-api-secret': zod.string().describe('Your Bybit API secret'),
          'bybit-vip-level': zod
            .enum(['VIP0', 'VIP1', 'VIP2', 'VIP3', 'VIP4', 'VIP5', 'SupremeVIP', 'Pro1', 'Pro2', 'Pro3', 'Pro4', 'Pro5'])
            .describe('Your Bybit VIP Level'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Bybit as a data provider for a live algorithm.'),
      OandaBrokerage: zod
        .object({
          id: zod.enum(['OandaBrokerage']).describe('Id of the module.'),
          'oanda-account-id': zod
            .string()
            .describe(
              "Your OANDA account id can be found on your OANDA Account Statement page (https://www.oanda.com/account/statement/). It follows the following format '###-###-######-###'."
            ),
          'oanda-access-token': zod
            .string()
            .describe(
              'Your OANDA API token. You can generate an API token from the Manage API Access page (https://www.oanda.com/account/tpa/personal_token).'
            ),
          'oanda-environment': zod.enum(['Practice', 'Trade']).describe('The environment to run in. Practice for fxTrade Practice, Trade for fxTrade.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Oanda as the brokerage or a data provider for a live algorithm.'),
      CharlesSchwabBrokerage: zod
        .object({
          id: zod.enum(['CharlesSchwabBrokerage']).describe('Id of the module.'),
          'charles-schwab-account-number': zod.string().describe('Your Charles Schwab account number.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Charles Schwab as a data provider or the brokerage for a live algorithm.'),
      TradeStationBrokerage: zod
        .object({
          id: zod.enum(['TradeStationBrokerage']).describe('Id of the module.'),
          'trade-station-client-id': zod.string().describe('Your TradeStation client Id.'),
          'trade-station-account-id': zod.string().describe('The TradeStation account Id.'),
          'trade-station-refresh-token': zod.string().describe('The TradeStation refresh token.'),
          'trade-station-environment': zod.enum(['live', 'paper']).describe('The environment to run the algorithm in.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using TradeStation as the brokerage or a data provider for a live algorithm.'),
      TastytradeBrokerage: zod
        .object({
          id: zod.enum(['TastytradeBrokerage']).describe('Id of the module.'),
          'tastytrade-account-number': zod.number().describe('Your Tastytrade account number.'),
          'tastytrade-refresh-token': zod.string().describe('The TradeStation refresh token.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Tastytrade as the brokerage or a data provider for a live algorithm.'),
      AlpacaBrokerage: zod
        .object({
          id: zod.enum(['AlpacaBrokerage']).describe('Id of the module.'),
          'alpaca-api-key': zod.string().describe('Your Alpaca API key.'),
          'alpaca-api-secret': zod.string().describe('Your Alpaca API secret.'),
        })
        .optional()
        .nullable()
        .describe('Settings for using Alpaca as a data provider for a live algorithm.'),
    })
    .optional()
    .nullable()
    .describe(
      'Dictionary of data provider configurations to be used in the live algorithm. Provide at least one. The order in which you define the providers defines their order of precedence.'
    ),
})

export const createLiveResponse = zod
  .object({
    responseCode: zod.string().optional().nullable().describe('Response code of the request.'),
    source: zod.string().optional().nullable().describe('Source of the API call.'),
    deployId: zod.string().optional().nullable().describe('Id of the live deployment.'),
    versionId: zod.coerce.number().optional().nullable().describe('Id of the LEAN version deployed.'),
    projectId: zod.coerce.number().optional().nullable().describe('Id of the project deployed.'),
    live: zod
      .object({
        message: zod.string().optional().nullable().describe('Error message.'),
        deployId: zod.string().optional().nullable().describe('Unique live algorithm deployment identifier (similar to a backtest id).'),
        status: zod
          .enum([
            'DeployError',
            'InQueue',
            'Running',
            'Stopped',
            'Liquidated',
            'Deleted',
            'Completed',
            'RuntimeError',
            'Invalid',
            'LoggingIn',
            'Initializing',
            'History',
          ])
          .optional()
          .nullable()
          .describe('State of the live deployment.'),
        cloneId: zod.coerce.number().optional().nullable().describe("The snapshot project Id for cloning the live development's source code."),
        launched: zod.coerce.date().optional().nullable().describe('Datetime the algorithm was launched in UTC.'),
        stopped: zod.coerce.date().optional().nullable().describe('Datetime the algorithm was stopped in UTC, null if its still running.'),
        brokerage: zod.string().optional().nullable().describe('Brokerage'),
        securityTypes: zod.string().optional().nullable().describe('Security types detected in the algorithm.'),
        datacenter: zod.string().optional().nullable().describe('Name of the datacenter where the algorithm is physically located.'),
        isPublicStreaming: zod.boolean().optional().nullable().describe('Flag to indicate if public streaming is enabled.'),
        public: zod.boolean().optional().nullable().describe('Flag to indicate if the algorithm is public.'),
        files: zod
          .array(
            zod
              .object({
                id: zod.coerce.number().optional().nullable().describe('ID of the project file. This can also be null.'),
                projectId: zod.coerce.number().optional().nullable().describe('ID of the project.'),
                name: zod.string().optional().nullable().describe('Name of a project file.'),
                content: zod.string().optional().nullable().describe('Contents of the project file.'),
                modified: zod.coerce.date().optional().nullable().describe('DateTime project file was modified.'),
                open: zod.boolean().optional().nullable().describe('Indicates if the project file is open or not.'),
                isLibrary: zod
                  .boolean()
                  .optional()
                  .nullable()
                  .describe("Indicates if the project file is a library or not. It's always false in live/read and backtest/read."),
              })
              .describe('File for a project.')
          )
          .optional()
          .nullable()
          .describe('Files present in the project that contains the algorithm.'),
        runtimeStatistics: zod
          .object({
            Equity: zod.string().optional().nullable().describe('Total portfolio value.'),
            Fees: zod.string().optional().nullable().describe('Transaction fee.'),
            Holdings: zod.string().optional().nullable().describe('Equity value of security holdings.'),
            'Net Profit': zod.string().optional().nullable().describe('Net profit.'),
            'Probabilistic Sharpe Ratio': zod.string().optional().nullable().describe('Probabilistic Sharpe Ratio.'),
            Return: zod.string().optional().nullable().describe('Return.'),
            Unrealized: zod.string().optional().nullable().describe('Unrealized profit/loss.'),
            Volume: zod.string().optional().nullable().describe('Total transaction volume.'),
          })
          .optional()
          .nullable(),
        charts: zod
          .object({
            name: zod.string().optional().nullable().describe('Name of the Chart.'),
          })
          .optional()
          .nullable()
          .describe('Contains the names of all charts'),
      })
      .optional()
      .nullable()
      .describe('Live algorithm instance result from the QuantConnect Rest API.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when deploying a live algorithm.')

/**
 * @summary Read details of a live algorithm.
 */
export const readLiveBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to read.'),
  })
  .describe('Request to read out a live algorithm.')

export const readLiveResponse = zod
  .object({
    message: zod.string().optional().nullable().describe('Error message.'),
    deployId: zod.string().optional().nullable().describe('Unique live algorithm deployment identifier (similar to a backtest id).'),
    status: zod
      .enum([
        'DeployError',
        'InQueue',
        'Running',
        'Stopped',
        'Liquidated',
        'Deleted',
        'Completed',
        'RuntimeError',
        'Invalid',
        'LoggingIn',
        'Initializing',
        'History',
      ])
      .optional()
      .nullable()
      .describe('State of the live deployment.'),
    cloneId: zod.coerce.number().optional().nullable().describe("The snapshot project Id for cloning the live development's source code."),
    launched: zod.coerce.date().optional().nullable().describe('Datetime the algorithm was launched in UTC.'),
    stopped: zod.coerce.date().optional().nullable().describe('Datetime the algorithm was stopped in UTC, null if its still running.'),
    brokerage: zod.string().optional().nullable().describe('Brokerage'),
    securityTypes: zod.string().optional().nullable().describe('Security types detected in the algorithm.'),
    datacenter: zod.string().optional().nullable().describe('Name of the datacenter where the algorithm is physically located.'),
    isPublicStreaming: zod.boolean().optional().nullable().describe('Flag to indicate if public streaming is enabled.'),
    public: zod.boolean().optional().nullable().describe('Flag to indicate if the algorithm is public.'),
    files: zod
      .array(
        zod
          .object({
            id: zod.coerce.number().optional().nullable().describe('ID of the project file. This can also be null.'),
            projectId: zod.coerce.number().optional().nullable().describe('ID of the project.'),
            name: zod.string().optional().nullable().describe('Name of a project file.'),
            content: zod.string().optional().nullable().describe('Contents of the project file.'),
            modified: zod.coerce.date().optional().nullable().describe('DateTime project file was modified.'),
            open: zod.boolean().optional().nullable().describe('Indicates if the project file is open or not.'),
            isLibrary: zod
              .boolean()
              .optional()
              .nullable()
              .describe("Indicates if the project file is a library or not. It's always false in live/read and backtest/read."),
          })
          .describe('File for a project.')
      )
      .optional()
      .nullable()
      .describe('Files present in the project that contains the algorithm.'),
    runtimeStatistics: zod
      .object({
        Equity: zod.string().optional().nullable().describe('Total portfolio value.'),
        Fees: zod.string().optional().nullable().describe('Transaction fee.'),
        Holdings: zod.string().optional().nullable().describe('Equity value of security holdings.'),
        'Net Profit': zod.string().optional().nullable().describe('Net profit.'),
        'Probabilistic Sharpe Ratio': zod.string().optional().nullable().describe('Probabilistic Sharpe Ratio.'),
        Return: zod.string().optional().nullable().describe('Return.'),
        Unrealized: zod.string().optional().nullable().describe('Unrealized profit/loss.'),
        Volume: zod.string().optional().nullable().describe('Total transaction volume.'),
      })
      .optional()
      .nullable(),
    charts: zod
      .object({
        name: zod.string().optional().nullable().describe('Name of the Chart.'),
      })
      .optional()
      .nullable()
      .describe('Contains the names of all charts'),
    projectName: zod.string().optional().nullable().describe('Name of the project the live algorithm is in.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Details a live algorithm from the live/read API endpoint.')

/**
 * @summary List all your past and current live trading deployments.
 */
export const listLiveBody = zod
  .object({
    projectId: zod
      .number()
      .optional()
      .nullable()
      .describe('Id of the project to include in response. If you omit this property, the response includes all your projects.'),
    status: zod
      .enum(['Running', 'Stopped', 'RuntimeError', 'Liquidated'])
      .optional()
      .nullable()
      .describe('Status of the live deployments to include in the response. If you omit this property, the response includes deployments with any status.'),
  })
  .describe('Request for a list of past and present live deployments.')

export const listLiveResponseLiveItemEquityMin = 0

export const listLiveResponse = zod
  .object({
    live: zod
      .array(
        zod
          .object({
            projectId: zod.coerce.number().optional().nullable().describe('Id of the project.'),
            deployId: zod.string().optional().nullable().describe('Id of the live deployment.'),
            status: zod.string().optional().nullable().describe('The current status of the deployment.'),
            launched: zod.coerce.date().optional().nullable().describe('The date and time when the deployment was launched.'),
            stopped: zod.coerce.date().optional().nullable().describe('The date and time when the deployment was stopped.'),
            brokerage: zod.string().optional().nullable().describe('The brokerage used for the deployment.'),
            subscription: zod.string().optional().nullable().describe("The chart to which you're subscribed."),
            equity: zod.coerce
              .number()
              .min(listLiveResponseLiveItemEquityMin)
              .optional()
              .nullable()
              .describe('The equity value associated with the deployment.'),
            environment: zod.string().optional().nullable().describe('The environment in which the deployment is running.'),
            description: zod.string().optional().nullable().describe('The project description.'),
            error: zod.string().optional().nullable().describe('The error message if there was a runtime error.'),
            leagues: zod.array(zod.string()).optional().nullable().describe('Quant Leagues the algorithm is enrolled in.'),
          })
          .describe('Summary of the live algorithm.')
      )
      .optional()
      .nullable()
      .describe('Live algorithms that pass the filters in the request.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('List of the live algorithms running which match the requested status.')

/**
 * @summary Get the logs of a live algorithm. The snapshot updates about every 5 minutes.
 */
export const readLiveLogBody = zod
  .object({
    format: zod.any().optional().nullable().describe('Format of the log results.'),
    projectId: zod.number().describe('Id of the project that contains the live running algorithm.'),
    algorithmId: zod.string().describe('Deploy Id (Algorithm Id) of the live running algorithm.'),
    startLine: zod.number().describe('Start line (inclusive) of logs to read. The lines numbers start at 0.'),
    endLine: zod.number().describe('End line (exclusive) of logs to read, where endLine - startLine <= 250.'),
    deploymentLogs: zod.boolean().optional().nullable().describe('Indicates if only the given deployment logs should be included in the response.'),
  })
  .describe('Request to read the logs of a specific algorithm.')

export const readLiveLogResponse = zod
  .object({
    logs: zod.array(zod.string()).optional().nullable().describe('List of logs from the live algorithm.'),
    length: zod.coerce.number().optional().nullable().describe('Total amount of rows in the logs across all live deployments for this project.'),
    deploymentOffset: zod.coerce.number().optional().nullable().describe('Number of log rows before the given deployment (the `algorithmId` in the request).'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Logs from a live algorithm.')

/**
 * @summary Read out the portfolio state of a live algorithm. The snapshot updates about every 10 minutes.
 */
export const readLivePortfolioBody = zod
  .object({
    projectId: zod.number().describe('Id of the project from which to read the live algorithm.'),
  })
  .describe('Request to read the portfolio state from a live algorithm.')

export const readLivePortfolioResponse = zod
  .object({
    portfolio: zod
      .object({
        holdings: zod
          .record(
            zod.string(),
            zod
              .object({
                a: zod.coerce.number().optional().nullable().describe('Average purchase price of the holding in the currency it trades in.'),
                q: zod.coerce.number().optional().nullable().describe('Quantity of the asset.'),
                p: zod.coerce.number().optional().nullable().describe('Current market price of the asset in the currency it trades in.'),
                v: zod.coerce.number().optional().nullable().describe('Current market value of the holding.'),
                u: zod.coerce.number().optional().nullable().describe('Unrealized profit/loss of the position.'),
                up: zod.coerce.number().optional().nullable().describe('Unrealized profit/loss percentage of the position.'),
              })
              .describe('Summary of asset holding.')
          )
          .optional()
          .nullable()
          .describe('Dictionary of algorithm holdings information, where the key is the Symbol Id.'),
        cash: zod
          .record(
            zod.string(),
            zod
              .object({
                securitySymbols: zod
                  .array(
                    zod.object({
                      value: zod.string().optional().nullable().describe('TODO'),
                      id: zod.string().optional().nullable().describe('TODO'),
                      permtick: zod.string().optional().nullable().describe('TODO'),
                    })
                  )
                  .optional()
                  .nullable(),
                symbol: zod.string().optional().nullable().describe('Gets the symbol used to represent this cash.'),
                amount: zod.coerce.number().optional().nullable().describe('Gets or sets the amount of cash held.'),
                conversionRate: zod.coerce.number().optional().nullable().describe('The currency conversion rate to the account base currency.'),
                currencySymbol: zod.string().optional().nullable().describe('The symbol of the currency.'),
                valueInAccountCurrency: zod.coerce.number().optional().nullable().describe('The value of the currency cash in the account base currency.'),
              })
              .describe('Represents a holding of a currency in cash.')
          )
          .optional()
          .nullable()
          .describe('Dictionary of algorithm cash currencies information, where the key is the currency ticker.'),
      })
      .optional()
      .nullable()
      .describe('Portfolio object with the holdings and cash information.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Contains holdings and cash of the live algorithm in the request criteria.')

/**
 * @summary Read out the orders of a live algorithm. The snapshot updates about every 10 minutes.
 */
export const readLiveOrderBody = zod
  .object({
    algorithmId: zod.string().optional().nullable().describe('Deploy Id (Algorithm Id) of the live running algorithm.'),
    start: zod.number().describe('Starting index of the orders to be fetched.'),
    end: zod.number().describe('Last index of the orders to be fetched. Note that end - start must be <= 1,000.'),
    projectId: zod.number().describe('Id of the project from which to read the live algorithm.'),
  })
  .describe('Request to read orders from a live algorithm.')

export const readLiveOrderResponse = zod.union([
  zod
    .object({
      progress: zod.coerce.number().optional().nullable().describe('Loading percentage of the data generation process.'),
      status: zod.enum(['loading']).optional().nullable().describe('Status of the data generation process.'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    })
    .describe('Response when the requested chart or orders are being generated.'),
  zod
    .object({
      orders: zod
        .array(
          zod
            .object({
              id: zod.coerce.number().optional().nullable().describe('Order ID.'),
              contingentId: zod.coerce.number().optional().nullable().describe('Order Id to process before processing this order.'),
              brokerId: zod
                .array(zod.string())
                .optional()
                .nullable()
                .describe('Brokerage Id for this order for when the brokerage splits orders into multiple pieces.'),
              symbol: zod
                .object({
                  value: zod.string().optional().nullable().describe('The current symbol for this ticker.'),
                  id: zod.string().optional().nullable().describe('The security identifier for this symbol.'),
                  permtick: zod.string().optional().nullable().describe('The ticker at IPO for this security.'),
                })
                .optional()
                .nullable()
                .describe(
                  'Represents a unique security identifier. This is made of two components, the unique SID and the Value. The value is the current ticker symbol while the SID is constant over the life of a security.'
                ),
              limitPrice: zod.coerce.number().optional().nullable().describe('Limit price of the Order.'),
              stopPrice: zod.coerce.number().optional().nullable().describe('Stop price of the Order.'),
              stopTriggered: zod
                .boolean()
                .optional()
                .nullable()
                .describe('Indicates if the stop price has been reached, so the limit order has been triggered.'),
              price: zod.coerce.number().optional().nullable().describe('Price of the Order.'),
              priceCurrency: zod.string().optional().nullable().describe('Currency for the order price.'),
              time: zod.coerce.date().optional().nullable().describe('Gets the UTC time the order was created.'),
              createdTime: zod.coerce.date().optional().nullable().describe('Gets the UTC time this order was created. Alias for Time.'),
              lastFillTime: zod.coerce
                .date()
                .optional()
                .nullable()
                .describe('Gets the UTC time the last fill was received, or null if no fills have been received.'),
              lastUpdateTime: zod.coerce
                .date()
                .optional()
                .nullable()
                .describe('Gets the UTC time this order was last updated, or null if the order has not been updated.'),
              canceledTime: zod.coerce
                .date()
                .optional()
                .nullable()
                .describe('Gets the UTC time this order was canceled, or null if the order was not canceled.'),
              quantity: zod.coerce.number().optional().nullable().describe('Number of shares to execute.'),
              type: zod
                .union([
                  zod.literal(0),
                  zod.literal(1),
                  zod.literal(2),
                  zod.literal(3),
                  zod.literal(4),
                  zod.literal(5),
                  zod.literal(6),
                  zod.literal(7),
                  zod.literal(8),
                  zod.literal(9),
                  zod.literal(10),
                  zod.literal(11),
                ])
                .optional()
                .nullable()
                .describe(
                  'Order type. 0=Market, 1=Limit, 2=StopMarket, 3=StopLimit, 4=MarketOnOpen, 5=MarketOnClose, 6=OptionExercise, 7=LimitIfTouched, 8=ComboMarket, 9=ComboLimit, 10=ComboLegLimit, 11=TrailingStop.'
                ),
              status: zod
                .union([
                  zod.literal(0),
                  zod.literal(1),
                  zod.literal(2),
                  zod.literal(3),
                  zod.literal(5),
                  zod.literal(6),
                  zod.literal(7),
                  zod.literal(8),
                  zod.literal(9),
                ])
                .optional()
                .nullable()
                .describe(
                  'Status of the Order. 0=New, 1=Submitted, 2=PartiallyFilled, 3=Filled, 5=Canceled, 6=None, 7=Invalid, 8=CancelPending, 9=UpdateSubmitted.'
                ),
              tag: zod.string().optional().nullable().describe('Tag the order with some custom data.'),
              securityType: zod
                .union([
                  zod.literal(0),
                  zod.literal(1),
                  zod.literal(2),
                  zod.literal(3),
                  zod.literal(4),
                  zod.literal(5),
                  zod.literal(6),
                  zod.literal(7),
                  zod.literal(8),
                  zod.literal(9),
                  zod.literal(10),
                  zod.literal(11),
                ])
                .optional()
                .nullable()
                .describe(
                  'Type of tradable security / underlying asset. 0=Base, 1=Equity, 2=Option, 3=Commodity, 4=Forex, 5=Future, 6=Cfd, 7=Crypto, 8=FutureOption, 9=Index, 10=IndexOption, 11=CryptoFuture.'
                ),
              direction: zod
                .union([zod.literal(0), zod.literal(1), zod.literal(2)])
                .optional()
                .nullable()
                .describe('Order Direction Property based off Quantity. 0=Buy, 1=Sell, 2=Hold.'),
              value: zod.coerce
                .number()
                .optional()
                .nullable()
                .describe('Gets the executed value of this order. If the order has not yet filled, then this will return zero.'),
              orderSubmissionData: zod
                .object({
                  bidPrice: zod.coerce.number().optional().nullable().describe('The bid price at order submission time.'),
                  askPrice: zod.coerce.number().optional().nullable().describe('The ask price at order submission time.'),
                  lastPrice: zod.coerce.number().optional().nullable().describe('The current price at order submission time.'),
                })
                .optional()
                .nullable()
                .describe('Stores time and price information available at the time an order was submitted.'),
              isMarketable: zod.boolean().optional().nullable().describe('Returns true if the order is a marketable order.'),
              properties: zod
                .object({
                  timeInForce: zod
                    .object({})
                    .optional()
                    .nullable()
                    .describe('Defines the length of time over which an order will continue working before it is cancelled.'),
                })
                .optional()
                .nullable()
                .describe('Additional properties of the order'),
              events: zod
                .array(
                  zod
                    .object({
                      algorithmId: zod.string().optional().nullable().describe('Algorithm Id, BacktestId or DeployId.'),
                      symbol: zod.string().optional().nullable().describe('Easy access to the order symbol associated with this event.'),
                      symbolValue: zod
                        .string()
                        .optional()
                        .nullable()
                        .describe('The current symbol for this ticker; It is a user friendly symbol representation.'),
                      symbolPermtick: zod.string().optional().nullable().describe('The original symbol used to generate this symbol.'),
                      orderId: zod.coerce.number().optional().nullable().describe('Id of the order this event comes from.'),
                      orderEventId: zod.coerce.number().optional().nullable().describe('The unique order event id for each order.'),
                      id: zod.string().optional().nullable().describe('The unique order event Id for each order.'),
                      status: zod
                        .enum(['new', 'submitted', 'partiallyFilled', 'filled', 'canceled', 'none', 'invalid', 'cancelPending', 'updateSubmitted'])
                        .optional()
                        .nullable()
                        .describe('Status of the Order.'),
                      orderFeeAmount: zod.coerce.number().optional().nullable().describe('The fee amount associated with the order.'),
                      orderFeeCurrency: zod.string().optional().nullable().describe('The fee currency associated with the order.'),
                      fillPrice: zod.coerce.number().optional().nullable().describe('Fill price information about the order.'),
                      fillPriceCurrency: zod.string().optional().nullable().describe('Currency for the fill price.'),
                      fillQuantity: zod.coerce.number().optional().nullable().describe('Number of shares of the order that was filled in this event.'),
                      direction: zod.enum(['buy', 'sell', 'hold']).optional().nullable().describe('Direction of the order.'),
                      message: zod.string().optional().nullable().describe('Any message from the exchange.'),
                      isAssignment: zod.boolean().optional().nullable().describe('True if the order event is an assignment.'),
                      stopPrice: zod.coerce.number().optional().nullable().describe('The current stop price.'),
                      limitPrice: zod.coerce.number().optional().nullable().describe('The current limit price.'),
                      quantity: zod.coerce.number().optional().nullable().describe('The current order quantity.'),
                      time: zod.coerce.number().optional().nullable().describe('The time of this event in unix timestamp.'),
                      isInTheMoney: zod.boolean().optional().nullable().describe("True if the order event's option is In-The-Money (ITM)."),
                    })
                    .describe('Change in an order state applied to user algorithm portfolio')
                )
                .optional()
                .nullable()
                .describe('The order events.'),
              trailingAmount: zod.coerce.number().optional().nullable().describe('Trailing amount for a trailing stop order.'),
              trailingPercentage: zod
                .boolean()
                .optional()
                .nullable()
                .describe('Determines whether the trailingAmount is a percentage or an absolute currency value.'),
              groupOrderManager: zod
                .object({
                  id: zod.coerce.number().optional().nullable().describe('The unique order group Id.'),
                  quantity: zod.coerce.number().optional().nullable().describe('The group order quantity.'),
                  count: zod.coerce.number().optional().nullable().describe('The total order count associated with this order group.'),
                  limitPrice: zod.coerce.number().optional().nullable().describe('The limit price associated with this order group if any.'),
                  orderIds: zod.array(zod.coerce.number()).optional().nullable().describe('The order Ids in this group.'),
                  direction: zod.coerce.number().optional().nullable().describe('Order Direction Property based off Quantity.'),
                })
                .optional()
                .nullable()
                .describe('Manager of a group of orders.'),
              triggerPrice: zod.coerce
                .number()
                .optional()
                .nullable()
                .describe('The price which, when touched, will trigger the setting of a limit order at limitPrice.'),
              triggerTouched: zod.boolean().optional().nullable().describe('Whether or not the triggerPrice has been touched.'),
            })
            .describe('Order struct for placing new trade.')
        )
        .optional()
        .nullable()
        .describe('Collection of orders.'),
      length: zod.coerce.number().optional().nullable().describe('Total number of returned orders'),
      success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
      errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
    })
    .describe('Contains orders and the number of orders of the live algorithm in the request criteria.'),
])

/**
 * @summary Read out the insights of a live algorithm. The snapshot updates about every 10 minutes.
 */
export const readLiveInsightBody = zod
  .object({
    algorithmId: zod.string().optional().nullable().describe('Deploy Id (Algorithm Id) of the live running algorithm.'),
    start: zod.number().optional().nullable().describe('Starting index of the insights to be fetched. Required if end > 100.'),
    end: zod.number().describe('Last index of the insights to be fetched. Note that end - start must be less than 100.'),
    projectId: zod.number().describe('Id of the project from which to read the live algorithm.'),
  })
  .describe('Request to read insights from a live algorithm.')

export const readLiveInsightResponse = zod
  .object({
    insights: zod
      .array(
        zod
          .object({
            id: zod.string().optional().nullable().describe('Id of the insight.'),
            groupId: zod.string().optional().nullable().describe('Id of the group of insights.'),
            sourceModel: zod.string().optional().nullable().describe('An identifier for the source model that generated this insight.'),
            generatedTime: zod.coerce.number().optional().nullable().describe('Gets the Unix time this insight was generated.'),
            closeTime: zod.coerce.number().optional().nullable().describe('Gets the Unix time this insight was closed.'),
            symbol: zod.string().optional().nullable().describe('Gets the symbol Id this insight is for.'),
            ticker: zod.string().optional().nullable().describe('Gets the symbol ticker this insight is for.'),
            type: zod.enum(['price', 'volatility']).optional().nullable().describe('Gets the type of insight.'),
            reference: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the initial reference value this insight is predicting against. That is, the price of the asset when the insight was created.'),
            referenceFinal: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the final reference value, used for scoring, this insight is predicting against.'),
            direction: zod.enum(['down', 'flat', 'up']).optional().nullable().describe('Gets the predicted direction.'),
            period: zod.coerce.number().optional().nullable().describe('Gets the period, in seconds, over which this insight is expected to come to fruition.'),
            magnitude: zod.coerce
              .number()
              .optional()
              .nullable()
              .describe('Gets the predicted percent change in the insight type (price/volatility). This value can be null.'),
            confidence: zod.coerce.number().optional().nullable().describe('Gets the confidence in this insight. This value can be null.'),
            weight: zod.coerce.number().optional().nullable().describe('Gets the portfolio weight of this insight. This value can be null.'),
            scoreFinal: zod.boolean().optional().nullable().describe("Gets whether or not this is the insight's final score."),
            scoreDirection: zod.coerce.number().optional().nullable().describe('Gets the direction score.'),
            scoreMagnitude: zod.coerce.number().optional().nullable().describe('Gets the magnitude score.'),
            estimatedValue: zod.coerce.number().optional().nullable().describe('Gets the estimated value of this insight in the account currency.'),
            tag: zod.string().optional().nullable().describe("The insight's tag containing additional information."),
          })
          .describe('Insight struct for emitting new prediction.')
      )
      .optional()
      .nullable()
      .describe('Collection of insights.'),
    length: zod.coerce.number().optional().nullable().describe('Total number of returned insights'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
  })
  .describe('Contains insights and the number of insights of the live algorithm in the request criteria.')

/**
 * @summary Liquidate a live algorithm from the specified project Id.
 */
export const liquidateLiveBody = zod
  .object({
    projectId: zod.number().describe('Project Id for the live instance to liquidate.'),
  })
  .describe('Request to liquidate a live algorithm.')

export const liquidateLiveResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Stop a live algorithm from the specified project Id.
 */
export const stopLiveBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to stop trading live.'),
  })
  .describe('Request to stop a live algorithm.')

export const stopLiveResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Send a live command to a live trading algorithm.
 */
export const createLiveCommandBody = zod
  .object({
    projectId: zod.number().describe('Project for the live instance we want to run the command against.'),
    command: zod.object({}).describe('The command to run.'),
  })
  .describe('Request to create a live command.')

export const createLiveCommandResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Broadcast a live command to all live algorithms in the organization.
 */
export const broadcastLiveCommandBody = zod
  .object({
    organizationId: zod.string().describe('Organization Id of the projects we would like to broadcast the command to'),
    excludeProjectId: zod
      .number()
      .optional()
      .nullable()
      .describe('Project for the live instance we want to exclude from the broadcast list. If null, all projects will be included.'),
    command: zod.object({}).describe('The command to run.'),
  })
  .describe('Request to create a live command.')

export const broadcastLiveCommandResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Create an optimization with the specified parameters.
 */
export const createOptimizationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to optimize.'),
    name: zod.string().describe('Name of the optimization.'),
    target: zod.enum([
      'TotalPerformance.PortfolioStatistics.SharpeRatio',
      'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
      'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
      'TotalPerformance.PortfolioStatistics.Drawdown',
    ]),
    targetTo: zod.enum(['min', 'max']),
    targetValue: zod.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
    strategy: zod.enum(['QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy']),
    compileId: zod.string().describe('Optimization compile Id.'),
    parameters: zod
      .array(
        zod.object({
          name: zod.string().describe('Name of optimization parameter.'),
          min: zod.number().describe('Minimum value of optimization parameter, applicable for boundary conditions.'),
          max: zod.number().describe('Maximum value of optimization parameter, applicable for boundary conditions.'),
          step: zod.number().describe('Movement, should be positive.'),
          minStep: zod
            .number()
            .optional()
            .nullable()
            .describe(
              'Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.'
            ),
        })
      )
      .describe('Optimization parameters.'),
    constraints: zod
      .array(
        zod
          .object({
            target: zod.enum([
              'TotalPerformance.PortfolioStatistics.SharpeRatio',
              'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
              'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
              'TotalPerformance.PortfolioStatistics.Drawdown',
            ]),
            operator: zod.enum(['LessOrEqual', 'Less', 'GreaterOrEqual', 'Greater', 'NotEqual', 'Equals']).describe('The target comparison operation.'),
            targetValue: zod.number().describe('The threshold value for the target constraint.'),
          })
          .describe("Backtests in the optimization job that don't respect this constraint are excluded from the optimization result.")
      )
      .optional()
      .nullable()
      .describe('Optimization constraints.'),
    estimatedCost: zod.number().describe('Estimated cost for optimization.'),
    nodeType: zod.enum(['O2-8', 'O4-12', 'O8-16']).describe('Optimization node types available in QuantConnect Cloud.'),
    parallelNodes: zod.number().describe('Number of parallel nodes for optimization.'),
  })
  .describe('Request to create an optimization job.')

export const createOptimizationResponse = zod
  .object({
    optimizations: zod
      .array(
        zod
          .object({
            optimizationId: zod.string().optional().nullable().describe('Id of the optimization job.'),
            projectId: zod.coerce.number().optional().nullable().describe('Id of the project the optimization belongs to.'),
            name: zod.string().optional().nullable().describe('Name of the optimization.'),
            status: zod.enum(['new', 'aborted', 'running', 'completed']).optional().nullable().describe('Status of the optimization job.'),
            nodeType: zod.enum(['O2-8', 'O4-12', 'O8-16']).optional().nullable().describe('Optimization node types available in QuantConnect Cloud.'),
            criterion: zod
              .object({
                target: zod
                  .enum([
                    'TotalPerformance.PortfolioStatistics.SharpeRatio',
                    'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
                    'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
                    'TotalPerformance.PortfolioStatistics.Drawdown',
                  ])
                  .optional()
                  .nullable(),
                extremum: zod.enum(['min', 'max']).optional().nullable(),
                targetValue: zod.coerce.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
              })
              .optional()
              .nullable(),
            created: zod.coerce.date().optional().nullable().describe('Date and time of when this optimization was created.'),
            psr: zod.coerce.number().optional().nullable().describe('Probabilistic Sharpe ratio statistic.'),
            sharpeRatio: zod.coerce.number().optional().nullable().describe('Sharpe ratio statistic.'),
            trades: zod.coerce.number().optional().nullable().describe('Number of trades in the best backtest (based on the criterion) of the optimziation.'),
            cloneId: zod.coerce.number().optional().nullable().describe('Id of project where this current project was originally cloned.'),
            outOfSampleDays: zod.coerce.number().optional().nullable().describe('Number out-of-sample days.'),
            outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out-of-sample data.'),
            parameters: zod
              .array(
                zod.object({
                  name: zod.string().describe('Name of optimization parameter.'),
                  min: zod.coerce.number().describe('Minimum value of optimization parameter, applicable for boundary conditions.'),
                  max: zod.coerce.number().describe('Maximum value of optimization parameter, applicable for boundary conditions.'),
                  step: zod.coerce.number().describe('Movement, should be positive.'),
                  minStep: zod.coerce
                    .number()
                    .optional()
                    .nullable()
                    .describe(
                      'Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.'
                    ),
                })
              )
              .optional()
              .nullable()
              .describe('Parameters used in this optimization.'),
          })
          .describe('Response received when launching an optimization job or listing all the optimization jobs of a project.')
      )
      .optional()
      .nullable()
      .describe('Collection of summarized optimization objects.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when creating an optimization or listing optimizations of a project.')

/**
 * @summary Update the name of an optimization.
 */
export const updateOptimizationBody = zod
  .object({
    optimizationId: zod.string().describe('Id of the optimization to update.'),
    name: zod.string().describe('Name to assign to the optimization.'),
  })
  .describe('Update the name of an optimization.')

export const updateOptimizationResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Read an optimization.
 */
export const readOptimizationBody = zod
  .object({
    optimizationId: zod.string().describe('Id of the optimization to read.'),
  })
  .describe('Request to read an optimization from a project.')

export const readOptimizationResponse = zod
  .object({
    optimization: zod
      .object({
        optimizationId: zod.string().optional().nullable().describe('Id of the optimization.'),
        snapshotId: zod.coerce.number().optional().nullable().describe('Snapshot Id of this optimization.'),
        projectId: zod.coerce.number().describe('Id of the project the optimization belongs to.'),
        name: zod.string().optional().nullable().describe('Name of the optimization.'),
        status: zod.enum(['new', 'aborted', 'running', 'completed']).optional().nullable().describe('Status of the optimization job.'),
        nodeType: zod.enum(['O2-8', 'O4-12', 'O8-16']).optional().nullable().describe('Optimization node types available in QuantConnect Cloud.'),
        parallelNodes: zod.coerce.number().optional().nullable().describe('Number of parallel nodes for the optimization.'),
        criterion: zod
          .object({
            target: zod
              .enum([
                'TotalPerformance.PortfolioStatistics.SharpeRatio',
                'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
                'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
                'TotalPerformance.PortfolioStatistics.Drawdown',
              ])
              .optional()
              .nullable(),
            extremum: zod.enum(['min', 'max']).optional().nullable(),
            targetValue: zod.coerce.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
          })
          .optional()
          .nullable(),
        runtimeStatistics: zod
          .object({
            Completed: zod.string().optional().nullable().describe('Number of completed backtests in the optimization job.'),
            Failed: zod.string().optional().nullable().describe('Number of failed backtests in the optimization job.'),
            Running: zod.string().optional().nullable().describe('Number of running backtests in the optimization job.'),
            'In Queue': zod.string().optional().nullable().describe('Number of backtests waiting in-queue in the optimization job.'),
            'Average Length': zod.string().time({}).optional().nullable().describe('The average time of each backtest in the optimization job (HH:MM:SS).'),
            'Total Runtime': zod.string().time({}).optional().nullable().describe('The total runtime of the optimization (HH:MM:SS).'),
            Total: zod.string().optional().nullable().describe('Number of backtests in the optimization job.'),
            Consumed: zod.string().optional().nullable().describe('Amount of QuantConnect Credit consumed by the optimization job.'),
          })
          .optional()
          .nullable(),
        constraints: zod
          .array(
            zod
              .object({
                target: zod.enum([
                  'TotalPerformance.PortfolioStatistics.SharpeRatio',
                  'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
                  'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
                  'TotalPerformance.PortfolioStatistics.Drawdown',
                ]),
                operator: zod.enum(['LessOrEqual', 'Less', 'GreaterOrEqual', 'Greater', 'NotEqual', 'Equals']).describe('The target comparison operation.'),
                targetValue: zod.coerce.number().describe('The threshold value for the target constraint.'),
              })
              .describe("Backtests in the optimization job that don't respect this constraint are excluded from the optimization result.")
          )
          .optional()
          .nullable()
          .describe('Optimization constraints.'),
        parameters: zod
          .array(
            zod.object({
              name: zod.string().describe('Name of optimization parameter.'),
              min: zod.coerce.number().describe('Minimum value of optimization parameter, applicable for boundary conditions.'),
              max: zod.coerce.number().describe('Maximum value of optimization parameter, applicable for boundary conditions.'),
              step: zod.coerce.number().describe('Movement, should be positive.'),
              minStep: zod.coerce
                .number()
                .optional()
                .nullable()
                .describe(
                  'Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.'
                ),
            })
          )
          .optional()
          .nullable()
          .describe('Optimization parameters.'),
        backtests: zod
          .record(
            zod.string(),
            zod.object({
              name: zod.string().optional().nullable().describe('The backtest name.'),
              id: zod.string().optional().nullable().describe('Id of the backtest.'),
              progress: zod.coerce
                .number()
                .optional()
                .nullable()
                .describe('Progress of the backtest as a percentage from 0-1 based on the days lapsed from start-finish.'),
              exitCode: zod.coerce.number().optional().nullable().describe('The exit code of this backtest.'),
              statistics: zod
                .array(zod.coerce.number())
                .optional()
                .nullable()
                .describe(
                  'The backtest statistics results. [alpha, annual standard deviation, annual variance, average loss (%), average win (%), beta, compounding annual return (%), drawdown (%), estimated strategy capacity, expectancy, information ratio, loss rate (%), net profit (%), probabilistic sharpe ratio, profit-loss ratio, sharpe ratio, total fees, total orders, tracking error, treynor ratio, win rate (%)]'
                ),
              parameterSet: zod
                .union([
                  zod.array(zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
                  zod.record(zod.string(), zod.union([zod.string(), zod.coerce.number(), zod.coerce.number()])),
                ])
                .optional()
                .nullable(),
              equity: zod
                .array(zod.array(zod.object({})).describe('Time and OHLC values.'))
                .optional()
                .nullable()
                .describe('The backtest equity chart series.'),
              startDate: zod.coerce.date().optional().nullable().describe('The backtest start date.'),
              endDate: zod.coerce.date().optional().nullable().describe('The backtest end date.'),
              outOfSampleDays: zod.coerce.number().optional().nullable().describe('The backtest out-of-sample day count.'),
              outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out-of-sample data.'),
            })
          )
          .optional()
          .nullable()
          .describe('Dictionary of optimization backtests.'),
        strategy: zod.enum(['QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy']).optional().nullable(),
        requested: zod.coerce.date().optional().nullable().describe('Optimization requested date and time.'),
        optimizationTarget: zod
          .enum([
            'TotalPerformance.PortfolioStatistics.SharpeRatio',
            'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
            'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
            'TotalPerformance.PortfolioStatistics.Drawdown',
          ])
          .optional()
          .nullable(),
        targetValue: zod.coerce.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
        gridLayout: zod
          .array(
            zod
              .object({
                chartName: zod.string().optional().nullable().describe('The chart name.'),
                width: zod.coerce.number().optional().nullable().describe('Width of the chart.'),
                height: zod.coerce.number().optional().nullable().describe('Height of the chart.'),
                row: zod.coerce.number().optional().nullable().describe('Number of rows of the chart.'),
                column: zod.coerce.number().optional().nullable().describe('Number of columns of the chart.'),
                sort: zod.coerce.number().optional().nullable().describe('Sort of the chart.'),
              })
              .describe('The chart display properties.')
          )
          .optional()
          .nullable()
          .describe('List with grid charts representing the grid layout.'),
        outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out of sample data.'),
        outOfSampleDays: zod.coerce.number().optional().nullable().describe('Number of days of out of sample days.'),
      })
      .optional()
      .nullable()
      .describe('Response received when reading an optimization job.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when reading an optimization.')

/**
 * @summary Delete an optimization.
 */
export const deleteOptimizationBody = zod
  .object({
    optimizationId: zod.string().describe('Id of the optimization to delete.'),
  })
  .describe('Delete an optimization.')

export const deleteOptimizationResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Abort an optimization.
 */
export const abortOptimizationBody = zod
  .object({
    optimizationId: zod.string().describe('Id of the optimization to abort.'),
  })
  .describe('Abort an optimization.')

export const abortOptimizationResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary List all the optimizations for a project.
 */
export const listOptimizationsBody = zod
  .object({
    projectId: zod.number().describe('Id of the Project to get a list of optimizations for.'),
  })
  .describe('Id of the Project to get a list of optimizations for.')

export const listOptimizationsResponse = zod
  .object({
    optimizations: zod
      .array(
        zod
          .object({
            optimizationId: zod.string().optional().nullable().describe('Id of the optimization job.'),
            projectId: zod.coerce.number().optional().nullable().describe('Id of the project the optimization belongs to.'),
            name: zod.string().optional().nullable().describe('Name of the optimization.'),
            status: zod.enum(['new', 'aborted', 'running', 'completed']).optional().nullable().describe('Status of the optimization job.'),
            nodeType: zod.enum(['O2-8', 'O4-12', 'O8-16']).optional().nullable().describe('Optimization node types available in QuantConnect Cloud.'),
            criterion: zod
              .object({
                target: zod
                  .enum([
                    'TotalPerformance.PortfolioStatistics.SharpeRatio',
                    'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
                    'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
                    'TotalPerformance.PortfolioStatistics.Drawdown',
                  ])
                  .optional()
                  .nullable(),
                extremum: zod.enum(['min', 'max']).optional().nullable(),
                targetValue: zod.coerce.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
              })
              .optional()
              .nullable(),
            created: zod.coerce.date().optional().nullable().describe('Date and time of when this optimization was created.'),
            psr: zod.coerce.number().optional().nullable().describe('Probabilistic Sharpe ratio statistic.'),
            sharpeRatio: zod.coerce.number().optional().nullable().describe('Sharpe ratio statistic.'),
            trades: zod.coerce.number().optional().nullable().describe('Number of trades in the best backtest (based on the criterion) of the optimziation.'),
            cloneId: zod.coerce.number().optional().nullable().describe('Id of project where this current project was originally cloned.'),
            outOfSampleDays: zod.coerce.number().optional().nullable().describe('Number out-of-sample days.'),
            outOfSampleMaxEndDate: zod.coerce.date().optional().nullable().describe('End date of out-of-sample data.'),
            parameters: zod
              .array(
                zod.object({
                  name: zod.string().describe('Name of optimization parameter.'),
                  min: zod.coerce.number().describe('Minimum value of optimization parameter, applicable for boundary conditions.'),
                  max: zod.coerce.number().describe('Maximum value of optimization parameter, applicable for boundary conditions.'),
                  step: zod.coerce.number().describe('Movement, should be positive.'),
                  minStep: zod.coerce
                    .number()
                    .optional()
                    .nullable()
                    .describe(
                      'Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.'
                    ),
                })
              )
              .optional()
              .nullable()
              .describe('Parameters used in this optimization.'),
          })
          .describe('Response received when launching an optimization job or listing all the optimization jobs of a project.')
      )
      .optional()
      .nullable()
      .describe('Collection of summarized optimization objects.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when creating an optimization or listing optimizations of a project.')

/**
 * @summary Estimate the execution time of an optimization with the specified parameters.
 */
export const estimateOptimizationBody = zod
  .object({
    projectId: zod.number().describe('Id of the project to optimize.'),
    name: zod.string().describe('Name of the optimization.'),
    target: zod.enum([
      'TotalPerformance.PortfolioStatistics.SharpeRatio',
      'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
      'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
      'TotalPerformance.PortfolioStatistics.Drawdown',
    ]),
    targetTo: zod.enum(['min', 'max']),
    targetValue: zod.number().optional().nullable().describe('Desired value for the optimization target statistic.'),
    strategy: zod.enum(['QuantConnect.Optimizer.Strategies.GridSearchOptimizationStrategy']),
    compileId: zod.string().optional().nullable().describe('Optimization compile Id.'),
    parameters: zod
      .array(
        zod.object({
          name: zod.string().describe('Name of optimization parameter.'),
          min: zod.number().describe('Minimum value of optimization parameter, applicable for boundary conditions.'),
          max: zod.number().describe('Maximum value of optimization parameter, applicable for boundary conditions.'),
          step: zod.number().describe('Movement, should be positive.'),
          minStep: zod
            .number()
            .optional()
            .nullable()
            .describe(
              'Minimal possible movement for current parameter, should be positive. Used by <code>Strategies.EulerSearchOptimizationStrategy</code> to determine when this parameter can no longer be optimized.'
            ),
        })
      )
      .describe('Optimization parameters.'),
    constraints: zod
      .array(
        zod
          .object({
            target: zod.enum([
              'TotalPerformance.PortfolioStatistics.SharpeRatio',
              'TotalPerformance.PortfolioStatistics.CompoundingAnnualReturn',
              'TotalPerformance.PortfolioStatistics.ProbabilisticSharpeRatio',
              'TotalPerformance.PortfolioStatistics.Drawdown',
            ]),
            operator: zod.enum(['LessOrEqual', 'Less', 'GreaterOrEqual', 'Greater', 'NotEqual', 'Equals']).describe('The target comparison operation.'),
            targetValue: zod.number().describe('The threshold value for the target constraint.'),
          })
          .describe("Backtests in the optimization job that don't respect this constraint are excluded from the optimization result.")
      )
      .optional()
      .nullable()
      .describe('Optimization constraints.'),
  })
  .describe('Request to estimate the cost of an optimization job.')

export const estimateOptimizationResponse = zod
  .object({
    estimate: zod
      .object({
        estimateId: zod.string().optional().nullable().describe('Estimate Id.'),
        time: zod.coerce.number().optional().nullable().describe('Estimated time in seconds to run the optimization job.'),
        balance: zod.coerce.number().optional().nullable().describe("The organization's QCC balance."),
      })
      .optional()
      .nullable()
      .describe('Response received when estimating the time to run an optimization job.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when estimating the cost of an optimization.')

/**
 * @summary Upload files to the Object Store.
 */
export const setObjectBody = zod
  .object({
    organizationId: zod.string().describe('Orgainization ID.'),
    key: zod.string().describe('Unique key to access the object in Object Store.'),
    objectData: zod.instanceof(File).describe('Object data to be stored.'),
  })
  .describe("Represents a binary file we we'd like to upload the file to upload to the Object Store.")

export const setObjectResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary Get Object Store file of a specific organization and key.
 */
export const getObjectBody = zod.union([
  zod
    .object({
      organizationId: zod.string().describe('Id of the organization that owns the Object Store.'),
      keys: zod.array(zod.string()).describe('Keys of the Object Store files.'),
    })
    .describe('Request to create a download job for some Object Store files.'),
  zod
    .object({
      organizationId: zod.string().describe('Id of the organization that owns the Object Store.'),
      jobId: zod.string().describe('Id of the download job for the files.'),
    })
    .describe('Request to get a download URL for some Object Store files.'),
])

export const getObjectResponse = zod
  .object({
    jobId: zod.string().optional().nullable().describe('Id of the job, which you can use to request a download URL.'),
    url: zod
      .string()
      .optional()
      .nullable()
      .describe(
        'The URL to download the object. This can also be null. To download the object, paste the full URL (including the URL parameters) into a browser.'
      ),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when fetching an Object Store file.')

/**
 * @summary Get Object Store properties of a specific organization and key. It doesn't work if the key is a directory in the Object Store.
 */
export const getObjectPropertiesBody = zod
  .object({
    organizationId: zod.string().describe('Id of the organization that owns the Object Store.'),
    key: zod.string().describe('Key in the Object Store.'),
  })
  .describe('Request to get Object Store properties of a specific organization and key.')

export const getObjectPropertiesResponse = zod
  .object({
    metadata: zod
      .object({
        key: zod.string().optional().nullable().describe('Object Store key.'),
        modified: zod.coerce.date().optional().nullable().describe('Last time it was modified.'),
        created: zod.coerce.date().optional().nullable().describe('Date this project was created.'),
        size: zod.coerce.number().optional().nullable().describe('Object Store file size.'),
        md5: zod.string().optional().nullable().describe('MD5 (hashing algorithm) hash authentication code.'),
        mime: zod.string().optional().nullable().describe('MIME type.'),
        preview: zod.string().optional().nullable().describe('Preview of the Object Store file content.'),
      })
      .optional()
      .nullable()
      .describe('Object Store file properties.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received when fetching Object Store file properties.')

/**
 * @summary Delete the Object Store file of a specific organization and key.
 */
export const deleteObjectBody = zod
  .object({
    organizationId: zod.string().describe('Id of the organization that owns the Object Store.'),
    key: zod.string().describe('Key of the Object Store file to delete.'),
  })
  .describe('Request to delete an object in the Object Store for a specific organization and key.')

export const deleteObjectResponse = zod
  .object({
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Base API response class for the QuantConnect API.')

/**
 * @summary List the Object Store files under a specific directory in an organization.
 */
export const listObjectBody = zod
  .object({
    organizationId: zod.string().describe('Id of the organization to list the Object Store files from.'),
    path: zod.string().optional().nullable().describe('Path to a directory in the Object Store.'),
  })
  .describe('Request to list the Object Store files under a specific directory in an organization.')

export const listObjectResponse = zod
  .object({
    path: zod.string().optional().nullable().describe('Path to the directory in the Object Store.'),
    objects: zod
      .array(
        zod
          .object({
            key: zod.string().optional().nullable().describe('Object Store key.'),
            name: zod.string().optional().nullable().describe('File or folder name.'),
            modified: zod.coerce.date().optional().nullable().describe('Last time it was modified.'),
            mime: zod.string().optional().nullable().describe('MIME type.'),
            folder: zod.boolean().optional().nullable().describe('True if it is a folder, false otherwise.'),
            size: zod.coerce.number().optional().nullable().describe('Object Store file size.'),
          })
          .describe('Summary information of the Object Store.')
      )
      .optional()
      .nullable()
      .describe(
        "List of directories and files stored in the directory at the given path. If the path contains directories, this list of objects doesn't contain the children of those directories."
      ),
    page: zod.coerce.number().optional().nullable().describe('The current page number in the paginated response.'),
    totalPages: zod.coerce.number().optional().nullable().describe('The total number of pages in the paginated response.'),
    objectStorageUsed: zod.coerce.number().optional().nullable().describe('Size of all objects stored in bytes.'),
    objectStorageUsedHuman: zod.string().optional().nullable().describe('Size of all the objects stored in human-readable format.'),
    success: zod.boolean().optional().nullable().describe('Indicate if the API request was successful.'),
    errors: zod.array(zod.string()).optional().nullable().describe('List of errors with the API call.'),
  })
  .describe('Response received containing a list of stored objects metadata, as well as the total size of all of them.')

/**
 * @summary Run a backtest for a few seconds to initialize the algorithm and get initialization errors if any.
 */
export const backtestInitAiToolBody = zod
  .object({
    language: zod.enum(['C#', 'Py']).describe('Programming language.'),
    files: zod
      .array(
        zod
          .object({
            name: zod.string().optional().nullable().describe('Name of a file.'),
            content: zod.string().optional().nullable().describe('Contents of the file.'),
          })
          .describe('File for a AI.')
      )
      .describe('Files to process.'),
  })
  .describe('Request to process files.')

export const backtestInitAiToolResponse = zod
  .object({
    state: zod.enum(['End', 'Error']).optional().nullable().describe('State of the backtest.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    payload: zod.string().optional().nullable().describe('Information about the backtest initialization.'),
    payloadType: zod.string().optional().nullable().describe('Type of the payload.'),
  })
  .describe('Response to a backtest initialization request.')

/**
 * @summary Show the code completion for a specific text input.
 */
export const completeAiToolBody = zod
  .object({
    language: zod.enum(['C#', 'Py']).describe('Programming language for the code completion.'),
    sentence: zod.string().describe('Sentence to complete.'),
    responseSizeLimit: zod.number().optional().nullable().describe('Maximum size of the responses.'),
  })
  .describe('Request to show code completion for a specific text input.')

export const completeAiToolResponse = zod
  .object({
    state: zod.enum(['End']).optional().nullable().describe('State of the code completion.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    payload: zod.array(zod.string()).optional().nullable().describe('Code completion suggestions.'),
    payloadType: zod.string().optional().nullable().describe('Type of the payload.'),
  })
  .describe('Response to a code completion request.')

/**
 * @summary Show additional context and suggestions for error messages.
 */
export const errorEnhanceAiToolBody = zod
  .object({
    language: zod.enum(['C#', 'Py']).describe('Programming language for the code completion.'),
    error: zod
      .object({
        message: zod.string().describe('Error message.'),
        stacktrace: zod.string().optional().nullable().describe('Stack trace of the error.'),
      })
      .describe('Error information.'),
  })
  .describe('Request to show additional context and suggestions for error messages.')

export const errorEnhanceAiToolResponse = zod
  .object({
    state: zod.string().optional().nullable().describe('State of the code completion.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    payload: zod.string().optional().nullable().describe('Error message suggestions.'),
    payloadType: zod.string().optional().nullable().describe('Type of the payload.'),
  })
  .describe('Response to error enhancement request.')

/**
 * @summary Update Python code to follow PEP8 style.
 */
export const pep8ConvertAiToolBody = zod
  .object({
    files: zod
      .array(
        zod
          .object({
            name: zod.string().optional().nullable().describe('Name of a file.'),
            content: zod.string().optional().nullable().describe('Contents of the file.'),
          })
          .describe('File for a AI.')
      )
      .describe('Files of the project.'),
  })
  .describe('Request to convert Python code to PEP8 style.')

export const pep8ConvertAiToolResponse = zod
  .object({
    state: zod.string().optional().nullable().describe('State of PEP8 conversion.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    payload: zod
      .object({})
      .optional()
      .nullable()
      .describe('A dictionary where the key is the file name and the value is the PEP8 converted code of that file.'),
    payloadType: zod.string().optional().nullable().describe('Type of the payload.'),
  })
  .describe('Response to a PEP8 conversion request.')

/**
 * @summary Check the syntax of a code.
 */
export const syntaxCheckAiToolBody = zod
  .object({
    language: zod.enum(['C#', 'Py']).describe('Programming language.'),
    files: zod
      .array(
        zod
          .object({
            name: zod.string().optional().nullable().describe('Name of a file.'),
            content: zod.string().optional().nullable().describe('Contents of the file.'),
          })
          .describe('File for a AI.')
      )
      .describe('Files to process.'),
  })
  .describe('Request to process files.')

export const syntaxCheckAiToolResponse = zod
  .object({
    state: zod.enum(['End', 'Error']).optional().nullable().describe('State of the syntax check.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    payload: zod.array(zod.string()).optional().nullable().describe('Code completion suggestions.'),
    payloadType: zod.string().optional().nullable().describe('Type of the payload.'),
  })
  .describe('Response to a syntax check request.')

/**
 * @summary Search for content in QuantConnect.
 */
export const searchAiToolBody = zod
  .object({
    language: zod.enum(['C#', 'Py']).describe('Programming language of the content to search.'),
    criteria: zod
      .array(
        zod
          .object({
            input: zod.string().describe('Input for the search.'),
            type: zod.enum(['Stubs', 'Forum', 'Docs', 'Examples']).describe('Type of the search criteria.'),
            count: zod.number().describe('Number of results to return.'),
          })
          .describe('Search criteria.')
      )
      .describe('Criteria for the search.'),
  })
  .describe('Request to search content in QuantConnect.')

export const searchAiToolResponse = zod
  .object({
    state: zod.enum(['End', 'Error']).optional().nullable().describe('State of the search.'),
    version: zod.coerce.number().optional().nullable().describe('Version of the response.'),
    retrivals: zod
      .array(
        zod
          .object({
            url: zod.string().optional().nullable().describe('Input for the search.'),
            score: zod.coerce.number().optional().nullable().describe('Relevance score of the search result.'),
            content: zod.string().optional().nullable().describe('Content of the search result.'),
            type: zod.coerce.number().optional().nullable().describe('Type of the search result. 0=Stubs, 1=Forum, 2=Docs, 3=Examples.'),
          })
          .describe('Search criteria.')
      )
      .optional()
      .nullable()
      .describe('List of search results.'),
    messageId: zod.coerce.number().optional().nullable().describe('Id of the message.'),
  })
  .describe('Response to a search request.')
